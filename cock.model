//====================================================================/
//　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　/
// artisoc                                                            /
//                                                                    /
//====================================================================/

Version = 4.2;



//-------------------------------------------------------
// Component Tree
//-------------------------------------------------------
UNIVERSE {
    Space map(0,0),Square_2D(400, 500, !Loop, North, 1, Map_3D){
        AgtType insect(0, 0)[0] {
            Dim ID(0, 0) As Integer = (0);
            Dim X(0, 0) <2>  As Double = (0.0);
            Dim Y(0, 0) <2>  As Double = (0.0);
            Dim Z(0, 0) <2>  As Double = (0.0);
            Dim Layer(0, 0) As Integer = (0);
            Dim Direction(0, 0) As Double = (0.0);
            Dim Angle(0, 0) As Double = (0.0);
            Dim next_vector(0, 0) <1> [3][3] As Double = (9*0.0);
            Dim forward_vector(0, 0) <1> [3] As Double = (3*0.0);
            Dim base_vector(0, 0)[3] As Double = (3*0.0);
            Dim angle_surface(0, 0) As Double = (0.0);
            Dim b_type(0, 0) <1>  As Integer = (0);
            Dim matrix(0, 0)[3][3] As Double = (9*0.0);
            Dim normal_vector(0, 0) <1> [3] As Double = (3*0.0);
            Dim do_type(0, 0) <1>  As Integer = (0);
            Dim ap_or_dis(0, 0) As Integer = (0);
            Dim a_flag(0, 0) As Boolean = (0);
            Dim position_type(0, 0) As Integer = (0);
            Dim touch(0, 0) <1> [3] As Integer = (3*0);
            Dim n_normal(0, 0)[3] As Integer = (3*0);
            Dim dis_surface(0, 0) As Integer = (0);
            Dim is_hemi(0, 0) As Boolean = (0);
            Dim is_back(0, 0) As Boolean = (0);
            Dim sum_repulsive_force(0, 0)[3] As Double = (3*0.0);
            Dim repulsive_vector(0, 0)[3][3] As Double = (9*0.0);
            Dim edge(0, 0)[3] As Double = (3*0.0);
            Dim edge_vector(0, 0)[3] As Double = (3*0.0);
            Dim edge_flag(0, 0) As Boolean = (0);
            Dim T_al(0, 0) As Integer = (0);
            Dim vector_cul(0, 0)[2] As Double = (2*0.0);
            Dim state(0, 0) As Integer = (0);
            Dim stop_time(0, 0) As Integer = (0);
            Dim time_of_randomwalk(0, 0) As Integer = (0);
            Dim pre_touch(0, 0)[3] As Integer = (3*0);
        }
        AgtType barrier(0, 0)[0] {
            Dim ID(0, 0) As Integer = (0);
            Dim X(0, 0) As Double = (0.0);
            Dim Y(0, 0) As Double = (0.0);
            Dim Z(0, 0) As Double = (0.0);
            Dim Layer(0, 0) As Integer = (0);
            Dim Direction(0, 0) As Double = (0.0);
            Dim Angle(0, 0) As Double = (0.0);
        }
        Dim fin(0, 0)[400][500][40] As Boolean = (8000000*0);
        Dim is_void(0, 0)[400][500][40] As Boolean = (8000000*0);
    }
    Dim CameraPointer(0, 0) As Agt = (0);
    Dim num_fin(0, 0) <6000>  As Integer = (0);
    Dim num_void_fin(0, 0) As Integer = (0);
    Dim num_fill_fin(0, 0) As Integer = (0);
    Dim num_insect(0, 0) As Integer = (0);
    Dim T(0, 0) As Integer = (0);
    Dim alpha(0, 0) As Double = (0.0);
    Dim rubble_rate(0, 0) As Double = (0.0);
    Dim T_ex(0, 0) As Integer = (0);
    Dim probability_stop_center(0, 0) As Double = (0.0);
    Dim probability_continue_periphery(0, 0) As Double = (0.0);
}


//-------------------------------------------------------
// Agent Variable Initial Data
//-------------------------------------------------------
Initial_Value {
    UNIVERSE.NUM_INSECT = 1(1);
    UNIVERSE.T = 1(100);
    UNIVERSE.ALPHA = 1(0.6);
    UNIVERSE.RUBBLE_RATE = 1(0.6);
}


//-------------------------------------------------------
// Agent Rule
//-------------------------------------------------------
#begin_rule UNIVERSE
Univ_Init{
	universe.probability_stop_center = 1 - 0.97 ^ (1/10)
	universe.probability_continue_periphery = 0.8 ^ (1/10)
	CreateAgtMulti(universe.map.insect,universe.num_insect)
	ClearConsoleScreen()
	//make_rubble_mix(0.6)
	read_barrier()
	//make_void()
	println("")
	println("start")
	universe.T = 10 ^ (universe.T_ex)
	println(universe.T)
}

sub read_barrier(){
dim i as Integer
dim j as Integer
dim k as Integer
dim n as Integer
dim s_data as String
dim count as Integer 
dim position(3) as Integer
dim ct_token as Integer
dim hoge as String
dim length as Integer

OpenFile("N_50_ave_small_random_barrier_position_list_T_10_2.csv",100,1)
s_data = ReadFile(100)
Do While (IsEofFile(100) == False)
	ct_token = CountToken(s_data)
	for i = 0 to ct_token - 2
		hoge =  GetToken(s_data,i)
		length = len(hoge) - 2
		position(i) = Cint(Mid(hoge,2,length))
	next i
	universe.map.is_void(position(0),position(1),position(2)) = True
	s_data = ReadFile(100)
Loop
CloseFile(100)
}

sub write_parameter(){
	dim n as Integer

	n = GetCountSimulationNumber()
	OpenFileCSV("w_N_"&universe.num_insect&"_ave_small_random_insect_position_list_T_"&universe.T&"_"&n&".csv",n,3)
	WriteFileCSV(n,"N",False)
	WriteFileCSV(n,universe.num_insect,false)
	WriteFileCSV(n,"T",False)
	WriteFileCSV(n,universe.T,false)
	WriteFileCSV(n,"alpha",False)
	WriteFileCSV(n,universe.alpha,false)
	WriteFileCSV(n,"r",False)
	WriteFileCSV(n,2,True)
	CloseFileCSV(n)
}

sub make_void(){
dim i as Integer
dim j as Integer
dim k as Integer

for k= 0 to 39
for j = 0 to GetHeightSpace(universe.map) -1
for i = 0 to GetWidthSpace(universe.map) -1
	if i == 0 or j == GetHeightSpace(universe.map)-1 or j == 0 or i == GetWidthSpace(universe.map) - 1 or k == 39 then
		universe.map.is_void(i,j,k) = true
	end if
next i
next j
next k
}

Univ_Step_Begin{

}

Univ_Step_End{

	//write_csv()
}

sub write_csv(){
	dim insectlist as AgtSet
	dim one as Agt
	dim count as Integer
	dim n as Integer

	n = GetCountSimulationNumber() mod 10
	count = GetCountStep()
	OpenFileCSV("new_N_"&universe.num_insect&"_ave_small_random_insect_position_list_T_"&universe.T&"_alpha_"&universe.alpha&"_"&n&".csv",n,3)
	MakeAgtSet(insectlist,universe.map.insect)
	for each one in insectlist
		WriteFileCSV(n,count,false)
		WriteFileCSV(n,one.ID,false)
		WriteFileCSV(n,one.X,false)
		WriteFileCSV(n,one.Y,false)
		WriteFileCSV(n,one.Z,false)
		WriteFileCSV(n,one.vector_cul(0),false)
		WriteFileCSV(n,one.vector_cul(1),True)
	next one
	CloseFileCSV(n)
}

Univ_Finish{
}

sub make_rubble_mix(rate as Double){
	dim tmp_rate as Double
	dim tmp_number as Integer
	dim max as Integer
	dim height as Integer
	dim width as Integer
	dim x as integer
	dim y as integer
	dim z as integer
	dim r as Double
	dim pattern as Integer

	tmp_rate = 0
	height = GetHeightSpace(universe.map)
	width = GetWidthSpace(universe.map)
	max = height * width * 40
	tmp_number = 0
	println("tmp_number is"&tmp_number)

	Do While tmp_rate < rate
		x = Int(Rnd() * (width))
		y = Int(Rnd() * (height))
		z = Int(Rnd() * (40))
		pattern = Int(Rnd() * 3)
		r = Rnd() * 100
		if x < 4 and y < 4 and z < 4 then
			
		elseif r < 33 then
			tmp_number = tmp_number + make_rubble_board(pattern,x,y,z)
		elseif r < 66 then
			tmp_number = tmp_number + make_rubble_box(x,y,z)
		else
			tmp_number = tmp_number + make_rubble_Pillar(pattern,x,y,z)
		end if		
		tmp_rate = tmp_number / max
		PrintLn("rate is "&tmp_rate)
	Loop
			println("tmp_number is"&tmp_number)
}

function make_rubble_board(pattern as Integer, x as Integer, y as integer ,z as integer)as Integer{
	dim t as Integer
	dim a as Integer
	dim b as Integer
	dim c as Integer
	dim one as Agt
	dim set as AgtSet
	dim temp as AgtSet
	dim ret as Integer
	dim flag as Boolean
	dim kill as AgtSet
	dim i as integer
	dim j as integer

	flag = false
	ret = 64
	if not universe.map.is_void(x,y,z) then
		if pattern == 0 and x< GetWidthSpace(universe.map) -8 and y < GetHeightSpace(universe.map) - 8 then //水平に置く
			Do While Not flag
				if z == 0 then
					flag = true
					break
				end if
				for j = 0 to 4
					for i = 0 to 4
						if universe.map.is_void(i,j,z-1) then
							flag = true
						end if
					next i
				next j
				z = z -1
			Loop
			for t = 0 to 63
				c = t / 8
				b = t Mod 8
				if not universe.map.is_void(x+b,y+c,z) then
					universe.map.is_void(x+b,y+c,z) = true
				else
					ret = ret - 1
				end if
			next t
		elseif pattern == 1 and y < GetHeightSpace(universe.map) - 8 and z < 40 - 8 then // 縦長に置く
			Do While Not flag
				if z == 0 then
					flag = true
					break
				end if
				for j = 0 to 4
					for i = 0 to 4
						if universe.map.is_void(i,j,z-1) then
							flag = true
						end if
					next i
				next j
				z = z -1
			Loop
			for t = 0 to 63
				a = t / 8
				b = t Mod 8
				if not universe.map.is_void(x,y+b,z+a) then
					universe.map.is_void(x,y+b,z+a) = true
				else
					ret = ret - 1
				end if
			next t
		elseif pattern == 2 and x< GetWidthSpace(universe.map) -8 and z < 40 - 8 then // 横長に置く
			Do While Not flag
				if z == 0 then
					flag = true
					break
				end if
				for j = 0 to 4
					for i = 0 to 4
						if universe.map.is_void(i,j,z-1) then
							flag = true
						end if
					next i
				next j
				z = z -1
			Loop
			for t = 0 to 63
				a = t / 8
				c = t Mod 8
				if not universe.map.is_void(x+c,y,z+a) then
					universe.map.is_void(x+c,y,z+a) = true
				else
					ret = ret - 1
				end if
			next one
		else
			ret = 0
		end if
	else
		ret = 0
	end if
	 
	return ret
}

function make_rubble_box(x as Integer,y as integer, z as integer)as Integer{
	dim t as Integer
	dim a as Integer
	dim b as Integer
	dim c as Integer
	dim one as Agt
	dim set as AgtSet
	dim temp as AgtSet
	dim ret as integer
	dim flag as Boolean
	dim kill as AgtSet
	dim i as integer
	dim j as integer

	ret = 64
	flag = false
	if x <= GetWidthSpace(universe.map) - 4 and y <= GetHeightSpace(universe.map) - 4 and z <= 40 - 4 then
		if not universe.map.is_void(x,y,z) then
			Do While Not flag
				if z == 0 then
					flag = true
					break
				end if
				for j = 0 to 4
					for i = 0 to 4
						if universe.map.is_void(i,j,z-1) then
							flag = true
						end if
					next i
				next j
				z = z -1
			Loop
			for t = 0 to 63
				a = t  / 16 
				b = t Mod (16)
				c = b / 4
				b = b Mod 4
 				if not universe.map.is_void(x+b,y+c,z+a) then
		  		universe.map.is_void(x+b,y+c,z+a) = true
		  	else
					ret = ret - 1		  		
		  	end if		  	
			next t
		else
			ret = 0
		end if
	else
		ret = 0
	end if
		
	 
	return ret
}

function make_rubble_Pillar(pattern as Integer,x as Integer,y as integer ,z as integer)as Integer{
	dim set as AgtSet
	dim a as Integer
	dim b as Integer
	dim one as agt
	dim temp as AgtSet
	dim t as Integer
	dim c as Integer
	dim ret as Integer
	dim flag as Boolean
		dim kill as AgtSet
			dim i as integer
	dim j as integer

	ret = 64
	flag = false
	if not universe.map.is_void(x,y,z) then
		if pattern == 0 and x <= GetWidthSpace(universe.map) - 16 and y <= GetHeightSpace(universe.map) - 2 and z <= 40 -2  then
		//横長の柱を作る
			Do While Not flag
				if z == 0 then
					flag = true
					break
				end if
				for j = 0 to 4
					for i = 0 to 4
						if universe.map.is_void(i,j,z-1) then
							flag = true
						end if
					next i
				next j
				z = z -1
			Loop
			for t = 0 to 63
	  		a = t  / 32 
	  		b = t Mod (32)
	  		c = b / 16
	  		b = b Mod 16
				if not universe.map.is_void(x+b,y+c,z+a) then
		  		universe.map.is_void(x+b,y+c,z+a) = true
		  	else
					ret = ret - 1		  		
		  	end if
	  	next one
		elseif pattern == 1 and x <= GetWidthSpace(universe.map) - 2 and y <= GetHeightSpace(universe.map) - 16 and z <= 40 -2 then
		//縦長の柱を作る
			Do While Not flag
				if z == 0 then
					flag = true
					break
				end if
				for j = 0 to 4
					for i = 0 to 4
						if universe.map.is_void(i,j,z-1) then
							flag = true
						end if
					next i
				next j
				z = z -1
			Loop
	 		for t = 0 to 63
	 			a = t  / 32 
	 			b = t Mod (32)
	 			c = b / 2
	 			b = b Mod 2
				if not universe.map.is_void(x+b,y+c,z+a) then
		 			universe.map.is_void(x+b,y+c,z+a) = true
				else
					ret = ret - 1		  	 		 		
		 		end if
	 		next t
	  elseif pattern == 2 and x <= GetWidthSpace(universe.map) - 2 and y <= GetHeightSpace(universe.map) - 2 and z <= 40 - 16 then //立ってる柱を作る
	  	Do While Not flag
				if z == 0 then
					flag = true
					break
				end if
				for j = 0 to 4
					for i = 0 to 4
						if universe.map.is_void(i,j,z-1) then
							flag = true
						end if
					next i
				next j
				z = z -1
			Loop
	 		for t = 0 to 63
	 			a = t  / 4 
	 			b = t Mod (4)
	 			c = b / 2
	 			b = b Mod 2
				if not universe.map.is_void(x+b,y+c,z+a) then
		 			universe.map.is_void(x+b,y+c,z+a) = true
		 		else
					ret = ret - 1		  	 		 		
		 		end if
	 		next one
	  else
	  	ret = 0
		end if
	else
		ret = 0
	end if
	 
	return ret
	}
#end_rule UNIVERSE




//-------------------------------------------------------
// Agent Rule
//-------------------------------------------------------
#begin_rule UNIVERSE.MAP.INSECT
Agt_Init{
my.Direction = rnd() * 90
my.forward_vector(0) = Cos(DegreeToRad(my.Direction))
my.forward_vector(1) = Sin(DegreeToRad(my.Direction))
my.do_type = 1
my.ap_or_dis = 1
my.normal_vector(2) = 1
My.pre_touch(2) = 1
my.touch(2) = 1
my.dis_surface = -1
my.edge_flag = false
my.X = 1 + rnd() *0.5
my.Y = 1 + rnd() *0.5
my.Z = 0
my.T_al = Int(Rnd()*10)
my.state = COLOR_BLACK
}

Agt_Step{
	dim i as Integer

	println("X is "&my.X)
	println("Y is "&my.Y)
	println("Z is "&my.Z)
	println("")
	for i = 0 to 2
		println("touch ("&i&") : "&my.touch(i))
	next i
		for i = 0 to 2
		println("pre_touch ("&i&") : "&my.pre_touch(i))
	next i
	if my.state == COLOR_BLUE then
		do_stop()
	else
		if in_central() then
			println("do_central")
			do_central()
		else
			my.state = COLOR_BLACK
			if is_touch_new_surface() then
				if Rnd() < 0.5 then
					println("move")
					move_new_surface()
				else
					for i = 0 to 2
						my.pre_touch(i) = my.touch(i)
					next i
									println("do_peripheral 1")
					do_peripheral()
				end if
			elseif is_disappear_surface() then
				if Rnd() < 0.5 then
				println("jump")
					jump_new_surface()
				else
					for i = 0 to 2
						my.pre_touch(i) = my.touch(i)
					next i
									println("do_peripheral 2")
					do_peripheral()
				end if
			else
				println("do_peripheral    3")
				do_peripheral()
			end if
		end if
	end if
	back_0()
	for i = 0 to 2
		println("forward("&i&") is "&my.forward_vector(i))
	next i
	for i = 0 to 2
		println("normal("&i&") is "&my.normal_vector(i))
	next i
	println("state is "&my.state)
	println("--------------------------------------------------------------")
}

function is_disappear_surface() as Boolean{
/*
今までいる面が途切れたらtrue,続いていらばfalse
*/
	dim f(3) as Integer
	dim grid(3) as Integer
	dim grid_al(3) as Integer
	dim i as Integer
	dim ret as Boolean

	for i = 0 to 2
		if my.forward_vector(i) < 0 then
			f(i) = -1
		elseif my.forward_vector(i) > 0 then
			f(i) = 1
		else
			f(i) = 0
		end if
	next i

	grid(0) = close_num(my.X) + f(0) - my.normal_vector(0)
	grid(1) = close_num(my.Y) + f(1) - my.normal_vector(1)
	grid(2) = close_num(my.Z) + f(2) - my.normal_vector(2)
	
	grid_al(0) = close_num(my.X) - my.normal_vector(0)
	grid_al(1) = close_num(my.Y) - my.normal_vector(1)
	grid_al(2) = close_num(my.Z) - my.normal_vector(2)

	for i = 0 to 2
		if grid(i) < 0 then
			grid(i) = 0
			ret = false
			return ret
		end if
		if grid_al(i) < 0 then
			grid_al(i) = 0
			ret = false
			return ret
		end if
		println("grid("&i&") : "&grid(i))
	next i
	for i = 0 to 2
		println("grid_al("&i&") : "&grid_al(i))
	next i

	if not universe.map.is_void(grid(0),grid(1),grid(2)) and not universe.map.is_void(grid_al(0) + f(0),grid_al(1),grid_al(2)) and my.X==Int(my.X) then
		ret = true
		if my.normal_vector(1) != 0 then
			my.b_type = 2
		else
			my.b_type = 1
		end if
		println("b_type in dis(x)")
	else
		if not universe.map.is_void(grid(0),grid(1),grid(2)) and not universe.map.is_void(grid_al(0),grid_al(1)+f(1),grid_al(2)) and my.Y==Int(my.Y) then
			ret = true
		if my.normal_vector(0) != 0 then
			my.b_type = 2
		else
			my.b_type = 0
		end if
			println("b_type in dis y")
		else
			if not universe.map.is_void(grid(0),grid(1),grid(2)) and not universe.map.is_void(grid_al(0),grid_al(1),grid_al(2)+f(2)) and my.Z==Int(my.Z) then
				ret = true
				if my.normal_vector(1) != 0 then
					my.b_type = 0
				else
					my.b_type = 1
				end if
				println("b_type in dis z")
			else
				ret = false
			end if
		end if
	end if

	return ret
}

sub jump_new_surface(){
	dim n as Integer
	dim i as Integer
	dim b as Integer
	dim pre(3) as Integer
	dim f(3) as Double

	for i = 0 to 2
		println("pre_touch(:"&i&") : "&my.pre_touch(i) )
	next i
	for i = 0 to 2
		println("touch(:"&i&") : "&my.touch(i) )
	next i
	
	for i = 0 to 2
		pre(i) = my.pre_touch(i)
		my.pre_touch(i) = my.touch(i)
		if my.normal_vector(i) != 0 then
			n = i
		end if
	next i

	b = my.b_type
	println(" b = "&b&"   n = "&n)
	
		for i =0 to 2
		f(i) = my.forward_vector(i)
		if f(i) != 0 then
			f(i) = f(i) / Abs(f(i))
		end if
	next i

	if b < 3 then
		if b == 0 then
			f(0) = 0
		elseif b == 1 then
			f(1) = 0
		elseif b == 2 then
			f(2) = 0
		end if
	end if

	my.ap_or_dis = -1
	
	if n == 0 then
		my.X = my.X - pre(0)
		my.Y = my.Y + f(1)
		my.Z = my.Z + f(2)
		if b == 1 then
			my.normal_vector(0) = 0
			my.normal_vector(1) = 0
			my.normal_vector(2) = f(2)
		else
			my.normal_vector(0) = 0
			my.normal_vector(1) = f(1)
			my.normal_vector(2) = 0
		end if
		back_surface(0)
	elseif n == 1 then
		my.X = my.X + f(0)
		my.Y = my.Y - pre(1)
		my.Z = my.Z + f(2)
		if b == 0 then
			my.normal_vector(0) = 0
			my.normal_vector(1) = 0
			my.normal_vector(2) = f(2)
		else
			my.normal_vector(0) = f(0)
			my.normal_vector(1) = 0
			my.normal_vector(2) = 0
		end if
		back_surface(1)
	else
		my.X = my.X + f(0)
		my.Y = my.Y + f(1)
		my.Z = my.Z - pre(2)
		if b == 1 then
			my.normal_vector(0) = f(0)
			my.normal_vector(1) = 0
			my.normal_vector(2) = 0
		else
			my.normal_vector(0) = 0
			my.normal_vector(1) = f(1)
			my.normal_vector(2) = 0
		end if

		back_surface(2)
	end if
	back_0()
	if not my.is_back then
		matrix()
		update_touch()
		My.is_back = false
	end if	

}

sub move_new_surface(){
//新しい面に移る動き
//位置は変わらずに方向のみ帰る
	dim n as Integer
	dim i as Integer
	dim b as Integer
	dim pre(3) as Integer
	dim f(3) as Double

	for i = 0 to 2
		pre(i) = my.pre_touch(i)
	next i

	for i = 0 to 2
		if my.touch(i) != 0 and my.pre_touch(i) != my.touch(i) then
			n = i
		end if
		my.pre_touch(i) = my.touch(i)
	next i

	println("  n = "&n)
	b = get_boundary(n)
	my.b_type = b
	println("b = "&b)
	my.ap_or_dis = 1
	matrix()
	update_normal_vector(n)
	forward_one_step()
}

sub update_normal_vector(n as Integer){
// normalの更新&do_typeの更新
	dim i as Integer

	for i = 0 to 2	
		if i == n then
			my.normal_vector(i) = my.touch(i)
		else
			my.normal_vector(i) = 0
		end if
	next i

	if n == 0 then
		if my.forward_vector(1) == 0 then
			my.do_type = 5
		elseif my.forward_vector(2) == 0 then
			my.do_type = 3
		else
			my.do_type = 4
		end if
	elseif n ==1 then
		if my.forward_vector(0) == 0 then
			my.do_type = 5
		elseif my.forward_vector(2) == 0 then
			my.do_type = 0
		else
			my.do_type = 2
		end if
	else
		if my.forward_vector(1) == 0 then
			my.do_type = 0
		elseif my.forward_vector(0) == 0 then
			my.do_type = 3
		else
			my.do_type = 1
		end if
	end if
}

function calculate_theta() as Double{
	dim theta as Double
	dim n as Integer
	dim i as Integer
	dim jud as Double
	dim f as Double

	for i = 0 to 2
		if my.normal_vector(i) != 0 then
			n = my.normal_vector(i)//正からふれてるかどうか
			break
		end if
	next i

	println("b_type"&my.b_type)

	if my.b_type == 0 then
		if i == 1 then
			f = my.forward_vector(2)
		elseif i == 2 then
			f = -my.forward_vector(1)
		else
			println("miss in theta1")
		end if
	elseif my.b_type == 1 then
		if i == 0 then
			f = -my.forward_vector(2)
		elseif i == 2 then
			f = my.forward_vector(0)
		else
			println("miss in theta2")
		end if
	elseif my.b_type == 2 then
		if i == 0 then
			f = my.forward_vector(1)
		elseif i == 1 then
			f = -my.forward_vector(0)
		else
			println("miss in theta3")
		end if
	else
		println("miss in theta4")
	end if

	jud = f * n * my.ap_or_dis
	if jud > 0 then
		theta = DegreeToRad(90)
	elseif jud < 0 then
		theta = DegreeToRad(270)
	else
		println("miss in theta5")
		println("jud :"&jud)
		println("n : "&n)
		println("f : "&f)
		theta = DegreeToRad(90)
	end if

	return theta
	}

sub matrix(){
	dim x(3) as Double
	dim y(3) as Double
	dim b(3) as Double
	dim R(3,3) as Double
	dim i as Integer
	dim j as Integer
	dim theta as Double
	dim n as Integer

	n = my.b_type
	x(0) = my.forward_vector(0)
	x(1) = my.forward_vector(1)
	x(2) = my.forward_vector(2)

	theta = calculate_theta()
	if n == 0 then
		b(0) = -1
		b(1) = 0
		b(2) = 0
	elseif n == 1 then
		b(0) = 0
		b(1) = -1
		b(2) = 0
	elseif n == 2 then
		b(0) = 0
		b(1) = 0
		b(2) = -1
	else
		println("原因ここやんけ")
	end if

	R(0,0) = b(0)^2 * (1 - Cos(theta)) + Cos(theta)
	R(0,1) = b(0) * b(1) * (1 - Cos(theta)) - b(2) * Sin(theta)
	R(0,2) = b(2) * b(0) * (1 - Cos(theta)) + b(1) * Sin(theta)

	R(1,0) = b(0) * b(1) * (1 - Cos(theta)) + b(2) * Sin(theta)
	R(1,1) = b(1)^2 * (1 - Cos(theta)) + Cos(theta)
	R(1,2) = b(1) * b(2) * (1 - Cos(theta)) - b(0) * Sin(theta)

	R(2,0) = b(2) * b(0) * (1 - Cos(theta)) - b(1) * Sin(theta)
	R(2,1) = b(1) * b(2) * (1 - Cos(theta)) + b(0) * Sin(theta)
	R(2,2) = b(2)^2 * (1 - Cos(theta)) + Cos(theta)

	for i = 0 to 2
		my.forward_vector(i) = x(0) * R(i,0) + x(1) * R(i,1) + x(2) * R(i,2)
		if Abs(my.forward_vector(i)) < 0.0000001 then
			my.forward_vector(i) = 0
		end if
	next i
}

//---------------------------------ここから下はコーディング済み--------------------------------------------

function get_boundary(n as Integer) as Integer{
/*
どの軸を中心に回るかを決定する。面を変えるときにどの軸を越えるかと言い換えられる。
*/
	dim i as Integer
	dim ret as Integer

	ret = -1
	for i = 0 to 2
		if i != n and my.normal_vector(i) == 0 then
			ret = i		
		end if
	next i

	return ret
}

sub update_touch() {
/*
一番近いマスを見つけそのマスの周りを見る。forwardとかからも考える
*/
//どのマスを見るべきかの式があいまい。
	dim grid(3) as Double
	dim f(3) as Double
	dim i as Integer

	println("")
	println("X "&my.X)
	println("Y "&my.Y)
	println("Z "&my.Z)
			
	grid(0) = close_num(my.X)
	grid(1) = close_num(my.Y)
	grid(2) = close_num(my.Z)

	for i = 0 to 2
		if my.forward_vector(i) == 0 then
			f(i) = 0
		else
			f(i) = Abs(my.forward_vector(i)) / my.forward_vector(i)
		end if
		println("f("&i&") : "&f(i))
	next i

	for i = 0 to 2
		println("grid("&i&") : "&grid(i))
	next i

	if my.X == 1 then
	//f(0) > 0 であれば普通に判定(0 or -1)
	//それ以外はtouch = 1
		if f(0) > 0 then
			if universe.map.is_void(grid(0) + f(0), grid(1) ,grid(2)) then
				my.touch(0) = -f(0)
			else
				my.touch(0) = 0
			end if
		else
			my.touch(0) = 1
		end if
	elseif  my.X == GetWidthSpace(universe.map) - 2 then
	 //f(0) < 0 であれば普通に判定(0 or 1)
	//それ以外はtouch = -1
		if f(0) < 0 then
			if universe.map.is_void(grid(0) + f(0), grid(1) ,grid(2)) then
				my.touch(0) = -f(0)
			else
				my.touch(0) = 0
			end if
		else
			my.touch(0) = -1
		end if
	else
		if grid(0) + f(0) < 0  then
			my.touch(0) = 1
		elseif grid(0) + f(0) > GetWidthSpace(universe.map) - 1 then
			my.touch(0) = -1
		else
			if universe.map.is_void(grid(0) - my.touch(0) , grid(1) ,grid(2)) and grid(0) == my.X then
				my.touch(0) = my.touch(0)
			elseif universe.map.is_void(grid(0) + f(0), grid(1) ,grid(2)) and grid(0) == my.X then
				my.touch(0) = -f(0)
			else
				my.touch(0) = 0
			end if
		end if
	end if

	if my.Y == 1 then
		if f(1) > 0 then
			if universe.map.is_void(grid(0), grid(1)+ f(1) ,grid(2)) then
				my.touch(1) = -f(1)
			else
				my.touch(1) = 0
			end if
		else
			my.touch(1) = 1
		end if
	elseif my.Y == GetHeightSpace(universe.map) - 2 then
		if f(1) < 0 then
			if universe.map.is_void(grid(0), grid(1)+ f(1) ,grid(2)) then
				my.touch(1) = -f(1)
			else
				my.touch(1) = 0
			end if
		else
			my.touch(1) = -1
		end if
	else
		if grid(1) + f(1) < 0 then
			my.touch(1) = 1
		elseif grid(1) + f(1) > GetHeightSpace(universe.map) - 1 then
			my.touch(1) = -1
		else
			if universe.map.is_void(grid(0), grid(1) - my.touch(1) ,grid(2)) and grid(1) == my.Y then
				my.touch(1) = my.touch(1)
			elseif universe.map.is_void(grid(0) , grid(1) + f(1) ,grid(2)) and grid(1) == my.Y then
				my.touch(1) = -f(1)
			else
				my.touch(1) = 0
			end if
		end if
	end if
	
	if my.Z == 0 then
		if f(2) > 0 then
			if universe.map.is_void(grid(0), grid(1) ,grid(2) + f(2)) then
				my.touch(2) = -f(2)
			else
				my.touch(2) = 0
			end if
		else
			my.touch(2) = 1
		end if
	elseif my.Z == 39 then
		if f(2) < 0 then
			if universe.map.is_void(grid(0), grid(1) ,grid(2) + f(2)) then
				my.touch(2) = -f(2)
			else
				my.touch(2) = 0
			end if
		else
			my.touch(2) = -1
		end if
	else
		if grid(2) + f(2) < 0 and my.Z == 0 then
			my.touch(2) = 1
		elseif grid(2) + f(2) > 39 then
			my.touch(2) = -1
		else
			if grid(2) - my.touch(2) < 0 or grid(2) + f(2) < 0 then
				my.touch(2) = 0
			elseif universe.map.is_void(grid(0), grid(1) ,grid(2) - my.touch(2)) and grid(2) == my.Z then
				my.touch(2) = my.touch(2)
			elseif universe.map.is_void(grid(0), grid(1) ,grid(2) + f(2)) and grid(2) == my.Z then
				my.touch(2) = -f(2)
			else
				my.touch(2) = 0
			end if
		end if
	end if
} 

sub back_surface(n as Integer){
	dim pre as Integer
	dim i as Integer
	dim f(3) as Double
	dim a(3) as Double

	a(0) = close_num(my.X) - my.normal_vector(0)
	a(1) = close_num(my.Y) - my.normal_vector(1)
	a(2) = close_num(my.Z) - my.normal_vector(2)

	for i =0 to 2
		f(i) = GetHistory(my.forward_vector(i),1)
		if f(i) != 0 then
			f(i) = f(i) / Abs(f(i))
		end if
		if a(i) < 0 then
			return
		end if
	next i


	if is_filled() then
		my.is_back = true
		prev_forward()
		my.X = GetHistory(my.X,1)
		my.Y = GetHistory(my.Y,1)
		my.Z = GetHistory(my.Z,1)
	else
		if check_void(a(0),a(1),a(2)) == 0 then
			pre = my.pre_touch(n)
			if n == 0 and check_void(a(0)+ pre + f(0),a(1),a(2)) == 1 then
				my.X = my.X + pre + f(0)
				my.Y = my.Y 
				my.Z = my.Z
			elseif n == 1 and check_void(a(0),a(1)+pre+f(1),a(2)) == 1 then
				my.X = my.X 
				my.Y = my.Y + pre + f(1)
				my.Z = my.Z 
			elseif check_void(a(0),a(1),a(2)+ pre + f(2)) == 1 then
				my.X = my.X 
				my.Y = my.Y 
				my.Z = my.Z + pre + f(2)
			else
				//ここに入りたくない
					my.is_back = true
					prev_forward()
					my.X = GetHistory(my.X,1)
					my.Y = GetHistory(my.Y,1)
					my.Z = GetHistory(my.Z,1)
			end if
			my.is_back = true
			prev_forward()
		end if
	end if
}

sub prev_forward(){
//面を移る前の状態に戻す
	dim i as Integer 
	
	for i = 0 to 2
		my.forward_vector(i) = GetHistory(my.forward_vector(i),1)
		my.touch(i) = GetHistory(my.touch(i),1)
		my.normal_vector(i) = GetHistory(my.normal_vector(i),1)
	next i
	my.do_type = GetHistory(my.do_type,1)
}


function is_touch_new_surface()as Boolean{

/*
新しい面に触れていたらtrue,振れていなければfalseを返す
*/
	dim ret as Boolean
	dim i as Integer

	ret = false

	for i = 0 to 2
		if my.touch(i) != 0 and my.pre_touch(i) != my.touch(i) then
			ret = true
		end if
	next i
	
	return ret
}


sub do_peripheral(){
//周辺部でどう動くか
	if is_stop_do_peripheral() then
		if Rnd() < 2/3 then //周辺部で止まるか、中央部に入るか
			println("invade")
			invade_central_zone()			
		else
			println("stop")
			stop_insect()
		end if
	else
		//壁に沿う方向を決定し、その方向に進む
		println("along")
		along_wall()
		forward_one_step()
	end if
}

sub along_wall(){
/*
壁に沿う動きにおいて、次の方向を決定する
1. nは空いている面。
2.その方向に向く
*/
	dim n as Integer
	dim i as Integer
	
	 n = empty_direction()
	 if n == 0 then
		 my.do_type = 0
		elseif n == 1 then
			my.do_type = 3
		else
			my.do_type = 5
		end if
	 println("n is "&n&" in along wall")
	 if my.touch(n) == 0 then
		 for i = 0 to 2
		 	if i == n and my.forward_vector(i) == 0 then
		 		my.forward_vector(i) = (-1) ^ ( Int( Rnd() * 2 ) )
		 	elseif i == n then
		 		my.forward_vector(i) = my.forward_vector(i) / Abs(my.forward_vector(i))
		 	else
		 		my.forward_vector(i) = 0
		 	end if
		 next i
		else
		 for i = 0 to 2
		 	if i == n then
		 		my.forward_vector(i) =  my.touch(n)
		 	else
		 		my.forward_vector(i) = 0
		 	end if
		 next i
		end if
}

function empty_direction()as Integer{
/*
触れていない面の中からランダムに一つ選ぶ
*/
	dim ret as Integer
	dim count as Integer
	dim empty as Integer
	dim i as Integer

	i = -1
	if my.touch(0) != 0 and my.touch(1) != 0 and my.touch(2) != 0 then
		for count = 0 to 2
			if Abs(my.forward_vector(count)) != 1 and my.normal_vector(count) == 0 then
				i = count
			end if
		next count
	else
		empty = 1
		Do Until empty == 0
			i = Int( Rnd() * 3 )
			empty = my.touch(i)
		Loop
	end if

	return i
}

sub invade_central_zone(){
/*
角度を決定し、一歩前進
*/
	decision_invade_angle()
	forward_one_step()	
}

sub decision_invade_angle(){
/*
侵入する角度の決定
*/
	dim n as Integer
	dim t as Integer
	dim x as Double
	dim y as Double
	dim z as Double
	dim theta as Double

	x = my.forward_vector(0)
	y = my.forward_vector(1)
	z = my.forward_vector(2)
	n = normal_num()
	t = touch_signal(n)
	theta = DegreeToRad(angle_invade()) * t

	if n == 0 then
		my.forward_vector(1) = Cos(theta) * y - Sin(theta) * z
		my.forward_vector(2) = Sin(theta) * y + Cos(theta) * z
	elseif n==1 then
		my.forward_vector(0) = Cos(theta) * x - Sin(theta) * z
		my.forward_vector(2) = Sin(theta) * x + Cos(theta) * z
	else
		my.forward_vector(0) = Cos(theta) * x - Sin(theta) * y
		my.forward_vector(1) = Sin(theta) * x + Cos(theta) * y
	end if
	
}

function touch_signal(n as Integer) as Integer{

	if my.touch(0) != 0 and n != 0 then
		Return my.touch(0)
	elseif my.touch(1) != 0 and n != 1 then
		Return my.touch(1)
	elseif my.touch(2) != 0 and n != 2 then
		Return my.touch(2)
	else
		println("error in touch_angle()")
		TerminateAgt(my)
	end if
}

function angle_invade() as Double{
/*
対数分布に従って5~175で返す
*/
	dim angle as Double
	dim mean as Double
	dim SD as Double

	mean = 36.6
	SD =  2.14 

	angle = mean + SD * Sqr(-2 * Log(Rnd())) * Sin(2 * PI() *  Rnd())
	return angle
}

function normal_num()as Integer{
/*
現在どの面の上に乗っているかを返す
xy平面　= 2     xz平面 = 1   yz平面 = 0
*/
	if My.normal_vector(0) != 0 then
		return 0
	elseif my.normal_vector(1) != 0 then
		return 1
	elseif my.normal_vector(2) != 0 then
		return 2
	else
		println("error in normal_num()")
		TerminateAgt(my)
	end if
}

function is_stop_do_peripheral()as Boolean{
/*
周辺の動作をやめるならtrue,そのまま続けるならfalseを返す
*/
	dim ret as Boolean
	dim r as Double

	r = 0.1
	r = Rnd()
	
	if r < universe.probability_continue_periphery then
		ret = false
	else
		ret = true
	end if
	
	return ret
}

function in_central() as Boolean{
	/*
	どこかが壁に接していたらfalse,どこも接していなければtrue
	touchが自分の下以外に触れていたら壁に触れていると判断
	*/
	dim ret as Boolean
	dim count as Integer
	dim i as Integer

	count = 0
	for i = 0 to 2
		if my.touch(i) != 0 then
			count = count + 1
		end if
	next i
	
	if count > 1 or is_disappear_surface() then
		ret = false
	else
		ret = True
	end if
	
	return ret
}

sub decide_direction_and_distance(){
/*
ランダムウォークで次に進む方向とその距離を決定する
*/
	my.Direction = rnd() * 360
	if my.normal_vector(0) != 0 then
		my.forward_vector(1) = Cos(DegreeToRad(my.Direction))
		my.forward_vector(2) = Sin(DegreeToRad(my.Direction))
	elseif my.normal_vector(1) != 0 then
		my.forward_vector(0) = Cos(DegreeToRad(my.Direction))
		my.forward_vector(2) = Sin(DegreeToRad(my.Direction))
	elseif my.normal_vector(2) != 0 then
		my.forward_vector(0) = Cos(DegreeToRad(my.Direction))
		my.forward_vector(1) = Sin(DegreeToRad(my.Direction))
	else
		println("miss")
	end if

	my.time_of_randomwalk = Create_steps_of_random_walk()
	My.state = COLOR_RED
	
}

function Create_steps_of_random_walk()as Integer{
/*
	何ステップの間だけランダムウォークをするのかを返す
*/
	dim func as Double
	dim steps as Integer
	dim prob as Double

	steps = 0
	func = 0
	prob = 0
	Do Until prob < func
		steps = Int(Rnd() * 1000)
		prob = Rnd()
	
		func = distribution_time_of_random_walk(steps)
	Loop
	
	return steps
}

function distribution_time_of_random_walk(steps as Integer) as Double{
	dim mean as Double
	dim ramda as Double
	dim ret as Double
	dim distance as Double

	distance = steps * 6
	mean = 12.32 //ここの平均を考え直すべき
	ramda = 1 / mean

	ret = ramda * Exp(-1 * ramda * distance)

	return ret
}

sub do_stop() {
//停止状態でどう動くか
	if my.stop_time > 0 then
		my.stop_time = my.stop_time - 1
//		println("my.stop_time :"&my.stop_time)
	else
		my.state = COLOR_BLACK
	end if
}

sub do_central(){
//中央部でどう動くか
dim i as Integer

	if is_stop_central() then
		stop_insect()
		my.time_of_randomwalk = 0
	else
		if my.state != COLOR_RED then
			decide_direction_and_distance()
		end if
		forward_one_step()
		if my.time_of_randomwalk > 0 then
			my.time_of_randomwalk = my.time_of_randomwalk - 1
		else
			my.time_of_randomwalk = 0
			my.state = COLOR_BLACK
		end if
	end if
}

sub forward_one_step(){
/*
1step分前進する
もし途中で障害物があればその位置で止まる
*/
	step_direction()
	if not is_step() then
		back_step()
	end if
	update_touch()
	update_normal()
}

sub stop_insect(){
/*
1.停止時間を設定
2.停止状態になる
*/
	my.stop_time = Create_stop_time()
	my.state = COLOR_BLUE
}

function Create_stop_time() as Integer{
/*
分布に従った停止時間を返す
*/
	dim func as Double
	dim steps as Integer
	dim prob as Double

	steps = 0
	func = 0
	prob = 0
	Do Until prob < func
	steps = Int(Rnd() * 10000) + 1
	prob = Rnd()
	
	func = distribution_stop_time(steps)
	Loop
	return steps
}

function distribution_stop_time(steps as Integer) as Double{
/*
停止時間の分布関数
*/
	dim time as Double
	dim ret as Double
	
	time = steps * 10
	ret = 0.93 * Exp(-time / 5.87) + 0.07 * Exp(-time / 700)

	return ret
}

function is_stop_central() as Boolean{
	/*
	中央部において止まるかどうか。止まるならtrue,止まらないならfalseを返す
	*/
	dim ret as Boolean
	dim thread as Double

	thread = universe.probability_stop_center
	if Rnd() < thread then
		ret = true
	else
		ret = false
	end if
	
	return ret
}

sub step_direction(){
/*
 	1step分前進する
 	位置をオーバーしてたら元に戻す
*/
	my.X = my.X + my.forward_vector(0) * 0.6
	my.Y = my.Y + my.forward_vector(1) * 0.6
	my.Z = my.Z + my.forward_vector(2) * 0.6

	back_0()
}

sub delete_touch_vector(){
//あり得ないtouchを消す
	dim type as Integer

	type = my.do_type
	
	if type == 0 then
		my.touch(0) = 0
	elseif type == 1 then
		my.touch(0) = 0
		my.touch(1) = 0
	elseif type == 2 then
		my.touch(0) = 0
		my.touch(2) = 0
	elseif type == 3 then
		my.touch(1) = 0
	elseif type == 4 then
		my.touch(1) = 0
		my.touch(2) = 0
	else
		my.touch(2) = 0
	end if
}

sub update_normal(){
//normalの正負を合わせる
	dim i as Integer
	dim n as Integer

	for i = 0 to 2
		if my.normal_vector(i) != 0 then
			my.normal_vector(i) = my.touch(i)
			n = i
		end if
	next i

	if n == 0 then
		if my.forward_vector(1) == 0 then
			my.do_type = 5
		elseif my.forward_vector(2) == 0 then
			my.do_type = 3
		else
			my.do_type = 4
		end if
	elseif n ==1 then
		if my.forward_vector(0) == 0 then
			my.do_type = 5
		elseif my.forward_vector(2) == 0 then
			my.do_type = 0
		else
			my.do_type = 2
		end if
	else
		if my.forward_vector(1) == 0 then
			my.do_type = 0
		elseif my.forward_vector(0) == 0 then
			my.do_type = 3
		else
			my.do_type = 1
		end if
	end if
}

function is_step() as Boolean{
	dim ret as Boolean

	if is_filled() then
		ret = false
	else
		if is_float() then
			ret = false
		else
			if not is_jump() then
				ret = true
			else
				ret = false
			end if
		end if
	end if

	return ret
}

function is_filled() as Boolean{
	dim i as Integer
	dim j as Integer
	dim k as Integer
	dim a(3) as Integer
	dim x(3) as Double
	dim g(3) as Integer
	dim ret as Boolean

	x(0) = my.X
	x(1) = my.Y
	x(2) = my.Z

		//DebugStr("近いマス")
	for i = 0 to 2
		a(i) = close_num(x(i))
		//DebugStr("a("&i&")"&"is"&a(i))
	next i

	ret = false
	for i = 0 to 2
		if a(i) == 0 then
			g(i) = 0
		else
			g(i) = 1
		end if
	next i
	
	for k = 0 to (1 + g(2))
	 for j = 0 to (1 + g(1))
	 	for i = 0 to (1 + g(0))
			if check_void(a(0)-g(0)+i,a(1)-g(1)+j,a(2)-g(2)+k) == 1 then
	 			if abs(a(0) - g(0) + i  - my.X) < 1 and abs(a(1) - g(1) + j  - my.y) < 1 and abs(a(2) - g(2) + k  - my.z) < 1 then
	 				ret = true
	 				return ret
	 			end if
	 		end if
	 	next i
	 next j
	next k

	return ret
}

function is_float() as Boolean{
	dim i as Integer
	dim j as Integer
	dim k as Integer
	dim a(3) as Integer
	dim x(3) as Double
	dim g(3) as Integer
	dim ret as Boolean

	x(0) = my.X
	x(1) = my.Y
	x(2) = my.Z

	for i = 0 to 2
		a(i) = close_num(x(i))
	next i

	ret = false
	for i = 0 to 2
		if a(i) == 0 then
			g(i) = 0
		else
			g(i) = 1
		end if
	next i

	if x(0) == 0 or x(1) == 0 or x(2) == 0 then
		ret = false
		return ret
	end if
	
	for k = 0 to (1 + g(2))
	 for j = 0 to (1 + g(1))
	 	for i = 0 to (1 + g(0))
	 		if check_void(a(0)-g(0)+i,a(1)-g(1)+j,a(2)-g(2)+k) == 1 then
	 			if abs(a(0) - g(0) + i  - my.X) > 1 and abs(a(1) - g(1) + j  - my.y) > 1 and abs(a(2) - g(2) + k  - my.z) > 1 then
	 				ret = true
	 				return ret
	 			end if
	 		end if
	 	next i
	 next j
	next k

	return ret
}

sub back_step(){
	dim n(3) as Integer
	dim diff_x as Double
	dim diff_y as Double
	dim diff_z as Double
	dim pre(3) as Double
	dim u(3) as Double
	dim k(3) as Double
	dim pre_n(3) as Double
	dim i as Integer
	dim ak(3) as Double 

	pre(0) = GetHistory(my.X,1)
	pre(1) = GetHistory(my.y,1)
	pre(2) = GetHistory(my.z,1)

	k(0) = 0
	k(1) = 0
	k(2) = 0

	u(0) = my.forward_vector(0)//my.X - pre_x
	u(1) = my.forward_vector(1)//my.y - pre_y
	u(2) = my.forward_vector(2)//my.z - pre_z

	n(0) = Int(my.X)
	n(1) = Int(my.Y)
	n(2) = Int(my.Z)

	pre_n(0) = Int(pre(0))
	pre_n(1) = Int(pre(1))
	pre_n(2) = Int(pre(2))

	for i = 0 to 2
		if n(i) == pre_n(i) or u(i) == 0 then
			k(i) = 0
		else
			if n(i) > pre_n(i) then
				k(i) = (n(i) - pre(i)) / u(i)
			else
				k(i) = (pre_n(i) - pre(i)) / u(i)
			end if
		end if
		ak(i) = Abs(k(i))
		if k(i) < 0 then
			k(i) = 0
		end if
	next i

	if ak(0) <= ak(1) and ak(1) <= ak(2) then
		my.X = pre(0) + k(2) * u(0)
		my.y = pre(1) + k(2) * u(1)
		my.z = pre(2) + k(2) * u(2)
		back_0()
		
		if not is_step() then
			my.X = pre(0) + k(1) * u(0)
			my.y = pre(1) + k(1) * u(1)
			my.z = pre(2) + k(1) * u(2)
			back_0()

			if not is_step() then
				my.X = pre(0) + k(0) * u(0)
				my.y = pre(1) + k(0) * u(1)
				my.z = pre(2) + k(0) * u(2)
				back_0()
			end if
		end if
	elseif ak(0) <= ak(2) and ak(2) <= ak(1) then
		my.X = pre(0) + k(1) * u(0)
		my.y = pre(1) + k(1) * u(1)
		my.z = pre(2) + k(1) * u(2)
		back_0()

		if not is_step() then
			my.X = pre(0) + k(2) * u(0)
			my.y = pre(1) + k(2) * u(1)
			my.z = pre(2) + k(2) * u(2)
			back_0()

			if not is_step() then
				my.X = pre(0) + k(0) * u(0)
				my.y = pre(1) + k(0) * u(1)
				my.z = pre(2) + k(0) * u(2)
				back_0()
			end if
		end if
	elseif ak(1) <= ak(0) and k(0) <= ak(2) then
		my.X = pre(0) + k(2) * u(0)
		my.y = pre(1) + k(2) * u(1)
		my.z = pre(2) + k(2) * u(2)
		back_0()

		if not is_step() then
			my.X = pre(0) + k(0) * u(0)
			my.y = pre(1) + k(0) * u(1)
			my.z = pre(2) + k(0) * u(2)
			back_0()

			if not is_step() then
				my.X = pre(0) + k(1) * u(0)
				my.y = pre(1) + k(1) * u(1)
				my.z = pre(2) + k(1) * u(2)
				back_0()
			end if
		end if
	elseif ak(1) <= ak(2) and k(2) <= ak(0) then
		my.X = pre(0) + k(0) * u(0)
		my.y = pre(1) + k(0) * u(1)
		my.z = pre(2) + k(0) * u(2)
		back_0()

		if not is_step() then
			my.X = pre(0) + k(2) * u(0)
			my.y = pre(1) + k(2) * u(1)
			my.z = pre(2) + k(2) * u(2)
			back_0()

			if not is_step() then
				my.X = pre(0) + k(1) * u(0)
				my.y = pre(1) + k(1) * u(1)
				my.z = pre(2) + k(1) * u(2)
				back_0()
			end if
		end if
	elseif ak(2) <= ak(0) and k(0) <= ak(1) then
		my.X = pre(0) + k(1) * u(0)
		my.y = pre(1) + k(1) * u(1)
		my.z = pre(2) + k(1) * u(2)
		back_0()

		if not is_step() then
			my.X = pre(0) + k(0) * u(0)
			my.y = pre(1) + k(0) * u(1)
			my.z = pre(2) + k(0) * u(2)
			back_0()

			if not is_step() then
				my.X = pre(0) + k(2) * u(0)
				my.y = pre(1) + k(2) * u(1)
				my.z = pre(2) + k(2) * u(2)
				back_0()
			end if
		end if
	else			
		my.X = pre(0) + k(0) * u(0)
		my.y = pre(1) + k(0) * u(1)
		my.z = pre(2) + k(0) * u(2)
		back_0()

		if not is_step() then
			my.X = pre(0) + k(1) * u(0)
			my.y = pre(1) + k(1) * u(1)
			my.z = pre(2) + k(1) * u(2)
			back_0()

			if not is_step() then
				my.X = pre(0) + k(2) * u(0)
				my.y = pre(1) + k(2) * u(1)
				my.z = pre(2) + k(2) * u(2)
				back_0()
			end if
		end if
	end if
}

sub back_0(){
	if my.X <= 1 then
		my.X = 1
	elseif my.X >= GetWidthSpace(universe.map) - 1 then
		my.X = GetWidthSpace(universe.map) - 1
	end if
	
	if my.y < 1 then
		my.y = 1
	elseif my.X >= GetHeightSpace(universe.map) - 1 then
		my.y = GetHeightSpace(universe.map) - 1
	end if

	if my.z <= 0 then
		my.z = 0
	elseif my.Z >= 39 then
		my.Z = 39
	end if
}

function is_pause() as Boolean{
//触ってる面が途切れたらtrueを返す
	dim type as Integer
	dim ret as Boolean
	dim nx as Integer
	dim ny as Integer
	dim nz as Integer
	dim p(3) as Integer
	dim f(3) as Double
	dim i as Integer
	dim minus(3) as Integer

	for i = 0 to 2
		if my.forward_vector(i) != 0 then
			f(i) = My.forward_vector(i)
			f(i) = f(i) / Abs(f(i))
		else
			f(i) = 0
		end if
		if f(i) < 0 then
			minus(i) = 1
		else
			minus(i) = 0
		end if
	next i
	
	nx = Int(my.X)// + minus(0)
	ny = Int(my.Y)// + minus(1)
	nz = Int(my.Z)// + minus(2)

	p(0) = Int(GetHistory(my.X,1))
	p(1) = Int(GetHistory(my.Y,1))
	p(2) = Int(GetHistory(my.Z,1))


	if nx != my.X then
		nx = nx + minus(0)
		p(0) = p(0) + minus(0)
	end if
	if ny != my.y then
		ny = ny + minus(1)
		p(1) = p(1) + minus(1)
	end if
	if nz != my.z then
		nz = nz + minus(2)
		p(2) = p(2) + minus(2)
	end if
	
	
	type = my.do_type

	if my.is_back or GetHistory(my.do_type,1) == 1 or GetHistory(my.do_type,1) == 2 or GetHistory(my.do_type,1) == 4 then
		ret = false
		return ret 
	end if

	if type == 0 then
		if my.normal_vector(1) == 0 then
			if my.touch(1) != 0 then
				if ny == 0 and my.touch(1) > 0 then
					ret = false
				else
					if nx == 0 then
						ret = false
					elseif check_void(nx,ny - my.touch(1),nz) == 1 and check_void(nx+f(0),ny - my.touch(1),nz) == 0 then
						if my.X == nx or p(0) == nx then
							ret = false
						else
							ret = true
						end if
					else
						ret = false
					end if
				end if
			else
				ret = false
			end if
		else
			if my.touch(2) != 0 then
				if nz == 0 and my.touch(2) > 0 then
					ret = false
				else
					if nx == 0 then
						ret = false
					elseif check_void(nx,ny,nz - my.touch(2)) == 1 and check_void(nx+f(0),ny,nz - my.touch(2)) == 0 then
						if my.X == nx or p(0) == nx then
							ret = false
						else
							ret = true
						end if
					else
						ret = false
					end if
				end if
			else
				ret = false
			end if
		end if
	elseif type == 1 then
		ret = false
	elseif type == 2 then
		ret = false
	elseif type == 3 then
		if my.normal_vector(0) == 0 then
			if my.touch(0) != 0 then
				if nx == 0 and my.touch(0) > 0 then
					ret = false
				else
					if ny == 0 then
						ret = false
					elseif check_void(nx - my.touch(0),ny,nz) == 1 and check_void(nx - my.touch(0),ny+f(1),nz) == 0 then
						if my.Y == ny or p(1) == ny then
							ret = false
						else
							ret = true
						end if
					else
						ret = false
					end if
				end if
			else
				ret = false
			end if
		else
			if my.touch(2) != 0 then
				if nz == 0 and my.touch(2) > 0 then
					ret = false
				else
					if ny == 0 then
						ret = false
					elseif check_void(nx,ny,nz - my.touch(2)) == 1 and check_void(nx,ny+f(1),nz - my.touch(2)) == 0 then
						if my.Y == ny or p(1) == ny then
							ret = false
						else
							ret = true
						end if
					else
						ret = false
					end if
				end if
			else
				ret = false
			end if
		end if
	elseif type == 4 then
		ret = false
	else
		if my.normal_vector(0) == 0 then
			if my.touch(0) != 0 then
				if nx == 0 and my.touch(0) > 0 then
					ret = false
				else
					if nz == 0 then
						ret = false
					elseif check_void(nx - my.touch(0),ny,nz) == 1 and check_void(nx - my.touch(0),ny,nz+f(2)) == 0 then
						if my.Z == nz or p(2) == nz then
							ret = false
						else
							ret = true
							//DebugStr("5")
						end if
					else
						ret = false
					end if
				end if
			else
				ret = false
			end if
		else
			if my.touch(1) != 0 then
				if ny == 0 and my.touch(1) > 0 then
					ret = false
				else
					if nz == 0 then
						ret = false
					elseif check_void(nx,ny - my.touch(1),nz) == 1 and check_void(nx,ny - my.touch(1),nz+f(2)) == 0 then
						if my.Z == nz or p(2) == nz then
							ret = false
						else
							ret = true
							//DebugStr("6")
						end if
					else
						ret = false
					end if
				end if
			else
				ret = false
			end if
		end if
	end if

	return ret
}

function is_jump() as Boolean{
//さっきまでの面を飛び出したかどうか
	dim type as Integer
	dim ret as Boolean
	dim nx as Integer
	dim ny as Integer
	dim nz as Integer

	nx = Int(my.X)
	ny = Int(my.Y)
	nz = Int(my.Z)
	
	type = my.do_type
	println("do_type :"&my.do_type)

	if type == 0 then
		if my.normal_vector(1) == 0 then
			if nz == 0 and my.normal_vector(2) > 0 then
				ret = false
			else
				if check_void(nx,ny,nz - my.normal_vector(2)) == 1 and check_void(nx+1,ny,nz - my.normal_vector(2)) == 1 then
					ret = false
				else
					if my.X == nx then
							ret = false
						else
							ret = true
						end if
				end if
			end if
		else
			if ny == 0 and my.normal_vector(1) > 0 then
				ret = false
			else
				if check_void(nx,ny - my.normal_vector(1),nz) == 1 and check_void(nx+1,ny - my.normal_vector(1),nz) == 1 then
					ret = false
				else
					if my.x == nx then
							ret = false
						else
							ret = true
						end if
				end if
			end if
		end if
	elseif type == 1 then
		if nz == 0 and my.normal_vector(2) > 0 then
			ret = false
		else
			if ny == my.Y then
				if check_void(nx,ny,nz - my.normal_vector(2)) == 1 and check_void(nx+1,ny,nz - my.normal_vector(2)) == 1 then
					ret = false
				else
					if my.x == nx then
							ret = false
						else
							ret = true
						end if
				end if
			elseif nx == my.X then
				if check_void(nx,ny ,nz - my.normal_vector(2)) == 1 and check_void(nx,ny+1,nz - my.normal_vector(2)) == 1 then
					ret = false
				else
					if my.y == ny then
							ret = false
						else
							ret = true
						end if
				end if
			else
				if check_void(nx,ny,nz - my.normal_vector(2)) == 1 and check_void(nx+1,ny,nz - my.normal_vector(2)) == 1 and check_void(nx,ny+1,nz - my.normal_vector(2)) == 1 and check_void(nx+1,ny+1,nz - my.normal_vector(2)) == 1  then
					ret = false
				else
					ret = true
				end if
			end if
		end if
	elseif type == 2 then
		if ny == 0 and my.normal_vector(1) > 0 then
			ret = false
		else
			if nz == my.z then
				if check_void(nx,ny- my.normal_vector(1),nz) == 1 and check_void(nx+1,ny- my.normal_vector(1),nz) == 1 then
					ret = false
				else
					if my.x == nx then
							ret = false
						else
							ret = true
						end if
				end if
			elseif nx == my.X then
				if check_void(nx,ny- my.normal_vector(1) ,nz) == 1 and check_void(nx,ny- my.normal_vector(1),nz+1) == 1 then
					ret = false
				else
					if my.Z == nz then
							ret = false
						else
							ret = true
						end if
				end if
			else
				if check_void(nx,ny- my.normal_vector(1),nz) == 1 and check_void(nx+1,ny- my.normal_vector(1),nz) == 1 and check_void(nx,ny- my.normal_vector(1),nz+1) == 1 and check_void(nx+1,ny- my.normal_vector(1),nz+1) == 1  then
					ret = false
				else
					ret = true
				end if
			end if
		end if
	elseif type == 3 then
		if my.normal_vector(0) == 0 then
			if nz == 0 and my.normal_vector(2) > 0 then
				ret = false
			else
				if check_void(nx,ny,nz - my.normal_vector(2)) == 1 and check_void(nx,ny+1,nz - my.normal_vector(2)) == 1 then
					ret = false
				else
					if my.y == ny then
							ret = false
						else
							ret = true
						end if
				end if
			end if
		else
			if nx == 0 and my.normal_vector(0) > 0 then
				ret = false
			else
				if check_void(nx - my.normal_vector(0),ny,nz) == 1 and check_void(nx - my.normal_vector(0),ny+1,nz) == 1 then
					ret = false
				else
					if my.y == ny then
							ret = false
						else
							ret = true
						end if
				end if
			end if
		end if
	elseif type == 4 then
		if nx == 0 and my.normal_vector(0) > 0 then
			ret = false
		else
			if nz == my.z then
				if check_void(nx- my.normal_vector(0),ny,nz)==1 and check_void(nx- my.normal_vector(0),ny+1,nz) == 1 then
					ret = false
				else
					if my.y == ny then
							ret = false
						else
							ret = true
						end if
				end if
			elseif ny == my.y then
				if check_void(nx- my.normal_vector(0),ny ,nz) == 1 and check_void(nx- my.normal_vector(0),ny,nz+1) == 1 then
					ret = false
				else
					if my.Z == nz then
							ret = false
						else
							ret = true
						end if
				end if
			else
				if check_void(nx- my.normal_vector(0),ny,nz) == 1 and check_void(nx- my.normal_vector(0),ny+1,nz) == 1 and check_void(nx- my.normal_vector(0),ny,nz+1) == 1 and check_void(nx- my.normal_vector(0),ny+1,nz+1) == 1  then
					ret = false
				else
					ret = true
				end if
			end if
		end if
	else
		if my.normal_vector(0) == 0 then
			if ny == 0 and my.normal_vector(1) > 0 then
				ret = false
			else
				if check_void(nx,ny - my.normal_vector(1),nz) == 1 and check_void(nx,ny - my.normal_vector(1),nz+1) == 1 then
					ret = false
				else
					if my.Z == nz then
							ret = false
						else
							ret = true
						end if
				end if
			end if
		else
			if nx == 0 and my.normal_vector(0) > 0 then
				ret = false
			else
				if check_void(nx - my.normal_vector(0),ny,nz) == 1 and check_void(nx - my.normal_vector(0),ny,nz+1) == 1 then
					ret = false
				else
					if my.Z == nz then
							ret = false
						else
							ret = true
						end if
				end if
			end if
		end if
	end if

	return ret
}

function close_num(x as Double) as Integer{
	dim n as Integer
	dim ret as Integer

	n = Int(x)

	if x - n >= 0.5 then
		ret = n + 1
	else
		ret = n
	end if

	return ret
}

function check_void(x as Double,y as Double,z as Double) as Integer{
	dim ret as Integer
	dim max(3) as Integer

	max(0) = GetWidthSpace(universe.map) - 1
	max(1) = GetHeightSpace(universe.map) - 1
	max(2) = 39

	if x < 0 or y < 0 or z < 0 or max(0) < x or max(1) < y or max(2) < z then
		return -1
	elseif universe.map.is_void(x,y,z) == true then
		return 1
	else
		return 0
	end if
	}
#end_rule UNIVERSE.MAP.INSECT




//-------------------------------------------------------
// Agent Rule
//-------------------------------------------------------
#begin_rule UNIVERSE.MAP.BARRIER
Agt_Init{

}

Agt_Step{

}
#end_rule UNIVERSE.MAP.BARRIER




//-------------------------------------------------------
// Simulation Definition Division
//-------------------------------------------------------
Single_Simulation {
    Step_Max = 100000;
    Time_Max = 0;
    End_Condition = "";
    Exec_Wait = 0;
    Exec_Wait_Max = 1000;
    Random_Generator = Java_Standard;
    Exec_Order = Random;
    Exec_Order_Random_First_Step_Only = No;
    Random_Seed = 0;
    Redraw_Timing = Step;
    Redraw_Interval = 1;
    Garbage_Interval = 0;
}


//-------------------------------------------------------
// Simulation Loop Definition Division
//-------------------------------------------------------
Repeat_Simulation {
    Value_Change = Linear;
    Initial_Value_Change_None {
        Repeat_Max = 7;
    }
    Initial_Value_Change_Linear {
        Variable_Name = "universe.T_ex";
        Exec_Times_Same_Value = 1;
        Start_Value = 1.0;
        Step_Value = 1.0;
        End_Value = 1.0;
    }
}


//-------------------------------------------------------
// 2 Dimension Map Display Definition Division
//-------------------------------------------------------
Map_Output {
    Map_Space_Name = "Universe.map";
    Map_Name = "aaa";
    Title = "aaa";
    Disable = No;
    Background_Color = 255, 255, 255;
    Position_x = 1540;
    Position_y = 13;
    Size_x = 639;
    Size_y = 760;
    Map_Cell_Size = 1;
    Remarks = Yes;
    Legend_Pos = Top;
    Font_Name = "Dialog";
    Font_Char_Set = 81;
    Font_Size = 12.0;
    Font_Style = 0;
    Font_Color = 0, 0, 0;
    Font_Background_Color = 255, 255, 255;
    FastDraw = Yes;
    Draw_Timing = Simulation_Step;
    Draw_Interval = 1;
    Axis_Label = "", "";
    Draw_Range = 0, 0, 400, 500;
    Ruled_Line = No;
    Text_Display = No;
    Text_Display_Variable_Name = "";
    Chess_Type_Display_Position = No;
    Background_Transparent = No;
    Target_Layer = 0;
    Coordinate_Display = No;
    Space_Kind = Square_2D;
    BG_Pict = No;
    BG_Type = 0;
    BG_Var_Name = "";
    BG_File_Name = "";
    Origin_Position = 2;
    Output_Group_Name = "";
    Output {
        Map_Element_Name = "insect";
        Map_Element = Agent_Variable;
        Output_Expression = "Universe.map.insect";
        Draw_Line = No;
        Collection_Name = "";
        Line_Type = 0;
        Line_Arrow = 0;
        Line_Width = 0;
        Line_Color = 0, 0, 0;
        Line_Type_Variable = "";
        Line_Arrow_Variable = "";
        Line_Width_Variable = "";
        Line_Color_Variable = "";
        Agent_Color = "Universe.map.insect.state";
        Marker_Id = 1;
        Effective_Figures = 0;
        Format_Id = 0;
        Agent_Image_Direction = No;
        Icon_Type = 0;
        Icon_Var_Name = "";
        Icon_Transparent = No;
        Icon_Enlarg_Reduce = No;
        Icon_File_Name = "";
        Num_Display = No;
        Num_Var_Name = "";
        Agent_Image_Magnify_by_value = Yes;
        Agent_Image_Magnify_Value = 1.0;
        Agent_Image_Magnify_Variable_Name = "Universe.map.insect.ID";
        Agent_Image_Transparency_by_value = Yes;
        Agent_Image_Transparency_Value = 0.0;
        Agent_Image_Transparency_Variable_Name = "Universe.map.insect.ID";
    }
}


//-------------------------------------------------------
// Control Panel Definition Division
//-------------------------------------------------------
Control_Panel {
    Display_Area = 0, 0, 416, 107;
    Display_Type = 1;
    Panel_Item {
        Item_Type = Edit_Box;
        Item_Name = "rubble_rate";
        Display_Area = 0, 0, 0, 0;
        Font_Name = "";
        Font_Char_Set = 0;
        Font_Size = 0.0;
        Font_Style = 0;
        Font_Color = 0, 0, 0;
        Font_Background_Color = 0, 0, 0;
        Var_Name = "Universe.rubble_rate";
        Text_Data = "0.6";
    }
    Panel_Item {
        Item_Type = Edit_Box;
        Item_Name = "num_insect";
        Display_Area = 0, 0, 0, 0;
        Font_Name = "";
        Font_Char_Set = 0;
        Font_Size = 0.0;
        Font_Style = 0;
        Font_Color = 0, 0, 0;
        Font_Background_Color = 0, 0, 0;
        Var_Name = "Universe.num_insect";
        Text_Data = "1";
    }
    Panel_Item {
        Item_Type = Edit_Box;
        Item_Name = "alpha";
        Display_Area = 0, 0, 0, 0;
        Font_Name = "";
        Font_Char_Set = 0;
        Font_Size = 0.0;
        Font_Style = 0;
        Font_Color = 0, 0, 0;
        Font_Background_Color = 0, 0, 0;
        Var_Name = "Universe.alpha";
        Text_Data = "0.6";
    }
}


//-------------------------------------------------------
// Space Initial Value Definition Divsion
//-------------------------------------------------------
Space_Initial {
}


//-------------------------------------------------------
// Other Miscellaneous Data Definition Division
//-------------------------------------------------------
Others_Data {
    Indent = 4;
    Rule_Colored = Yes;
    Rule_LineNo = Yes;
    Window_Hide_Run = 1;
    Debug_Position_x = 598;
    Debug_Position_y = 28;
    Debug_Size_x = 400;
    Debug_Size_y = 200;
    Console_Position_x = 2;
    Console_Position_y = -11;
    Console_Size_x = 360;
    Console_Size_y = 737;
    Componen_Tree_Position_x = -24;
    Componen_Tree_Position_y = -3;
    Componen_Tree_Size_x = 250;
    Componen_Tree_Size_y = 400;
    Console_Background_Color = 16777215;
    Console_Foreground_Color = 255;
    Console_DisplayLines_Max = 500;
    plug_in_module_name = "";
    Font_Name = "Dialog";
    Font_Char_Set = 0;
    Font_Size = 14.0;
    Font_Style = 0;
    Font_Color = 0, 0, 0;
    Font_Background_Color = 0, 0, 0;
}


//-------------------------------------------------------
// Network Information Definition Division
//-------------------------------------------------------
Network_Info {
    Global_Space_Area = 0, 0, 100, 100;
    Local_Space_Info {
    }
}


//-------------------------------------------------------
// Space Map Initial Value Definition Division
//-------------------------------------------------------
Space_Map_Initial_Value {
    Space_Path_Name = Universe.map;
    Background_Image_File_Path_Name = "";
    Origin_Position = Left_Bottom;
    Space_Variable {
        Variable = Universe.map.fin,(8000000*0);
        Marker_Id = 1;
        Min_Value = "";
        Max_Value = "";
        Min_Value_Color = 255, 0, 0;
        Max_Value_Color = 0, 255, 255;
    }
    Space_Variable {
        Variable = Universe.map.is_void,(8000000*0);
        Marker_Id = 1;
        Min_Value = "";
        Max_Value = "";
        Min_Value_Color = 255, 0, 0;
        Max_Value_Color = 0, 255, 255;
    }
}


//-------------------------------------------------------
// Window Location Definition Division
//-------------------------------------------------------
Window_Rectangle {
    Window_Name = Main_Window, -9, -9, 2578, 1408;
    Window_Name = Output_Setting_Window, 1064, 529, 480, 350;
    Window_Name = Artisoc_Help_Window, 10, 10, 730, 732;
    Window_Name = Map_3D_Setting_Window, 631, 271, 680, 500;
    Window_Name = Space_3D_Setting_Window, 746, 251, 450, 540;
}


//-------------------------------------------------------
// Help Favorite Division
//-------------------------------------------------------
Help_Favorite {
}


//-------------------------------------------------------
// Model Description Division
//-------------------------------------------------------
Model_Description {
    Universe {
        Function Univ_Init {
        }
        Function read_barrier {
        }
        Function write_parameter {
        }
        Function make_void {
        }
        Function Univ_Step_Begin {
        }
        Function Univ_Step_End {
        }
        Function write_csv {
        }
        Function Univ_Finish {
        }
        Function make_rubble_mix {
        }
        Function make_rubble_board {
        }
        Function make_rubble_box {
        }
        Function make_rubble_Pillar {
        }
    }
    Space Universe.map {
    }
    Agent Universe.map.insect {
        Function Agt_Init {
        }
        Function Agt_Step {
        }
        Function is_disappear_surface {
        }
        Function jump_new_surface {
        }
        Function move_new_surface {
        }
        Function update_normal_vector {
        }
        Function calculate_theta {
        }
        Function matrix {
        }
        Function get_boundary {
        }
        Function update_touch {
        }
        Function back_surface {
        }
        Function prev_forward {
        }
        Function is_touch_new_surface {
        }
        Function do_peripheral {
        }
        Function along_wall {
        }
        Function empty_direction {
        }
        Function invade_central_zone {
        }
        Function decision_invade_angle {
        }
        Function touch_signal {
        }
        Function angle_invade {
        }
        Function normal_num {
        }
        Function is_stop_do_peripheral {
        }
        Function in_central {
        }
        Function decide_direction_and_distance {
        }
        Function Create_steps_of_random_walk {
        }
        Function distribution_time_of_random_walk {
        }
        Function do_stop {
        }
        Function do_central {
        }
        Function forward_one_step {
        }
        Function stop_insect {
        }
        Function Create_stop_time {
        }
        Function distribution_stop_time {
        }
        Function is_stop_central {
        }
        Function step_direction {
        }
        Function delete_touch_vector {
        }
        Function update_normal {
        }
        Function is_step {
        }
        Function is_filled {
        }
        Function is_float {
        }
        Function back_step {
        }
        Function back_0 {
        }
        Function is_pause {
        }
        Function is_jump {
        }
        Function close_num {
        }
        Function check_void {
        }
    }
    Agent Universe.map.barrier {
        Function Agt_Init {
        }
        Function Agt_Step {
        }
    }
}
