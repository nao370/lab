//====================================================================/
//　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　/
// artisoc                                                            /
//                                                                    /
//====================================================================/

Version = 4.0;



//-------------------------------------------------------
// Component Tree
//-------------------------------------------------------
UNIVERSE {
    Space map(0,0),Square_2D(400, 500, !Loop, North, 1, Map_3D){
        AgtType insect(0, 0)[0] {
            Dim ID(0, 0) As Integer = (0);
            Dim X(0, 0) <2>  As Double = (0.0);
            Dim Y(0, 0) <2>  As Double = (0.0);
            Dim Z(0, 0) <2>  As Double = (0.0);
            Dim Layer(0, 0) As Integer = (0);
            Dim Direction(0, 0) As Double = (0.0);
            Dim Angle(0, 0) As Double = (0.0);
            Dim next_vector(0, 0) <1> [3][3] As Double = (9*0.0);
            Dim forward_vector(0, 0) <1> [3] As Double = (3*0.0);
            Dim base_vector(0, 0)[3] As Double = (3*0.0);
            Dim angle_surface(0, 0) As Double = (0.0);
            Dim b_type(0, 0) <1>  As Integer = (0);
            Dim matrix(0, 0)[3][3] As Double = (9*0.0);
            Dim normal_vector(0, 0) <1> [3] As Double = (3*0.0);
            Dim do_type(0, 0) <1>  As Integer = (0);
            Dim ap_or_dis(0, 0) As Integer = (0);
            Dim a_flag(0, 0) As Boolean = (0);
            Dim position_type(0, 0) As Integer = (0);
            Dim touch(0, 0) <1> [3] As Integer = (3*0);
            Dim n_normal(0, 0)[3] As Integer = (3*0);
            Dim dis_surface(0, 0) As Integer = (0);
            Dim is_hemi(0, 0) As Boolean = (0);
            Dim is_back(0, 0) As Boolean = (0);
            Dim sum_repulsive_force(0, 0)[3] As Double = (3*0.0);
            Dim repulsive_vector(0, 0)[3][3] As Double = (9*0.0);
            Dim edge(0, 0)[3] As Double = (3*0.0);
            Dim edge_vector(0, 0)[3] As Double = (3*0.0);
            Dim edge_flag(0, 0) As Boolean = (0);
            Dim T_al(0, 0) As Integer = (0);
            Dim vector_cul(0, 0)[2] As Double = (2*0.0);
            Dim state(0, 0) As Integer = ();
            Dim stop_time(0, 0) As Integer = ();
        }
        AgtType barrier(0, 0)[0] {
            Dim ID(0, 0) As Integer = (0);
            Dim X(0, 0) As Double = (0.0);
            Dim Y(0, 0) As Double = (0.0);
            Dim Z(0, 0) As Double = (0.0);
            Dim Layer(0, 0) As Integer = (0);
            Dim Direction(0, 0) As Double = (0.0);
            Dim Angle(0, 0) As Double = (0.0);
        }
        Dim fin(0, 0)[400][500][40] As Boolean = (8000000*0);
        Dim is_void(0, 0)[400][500][40] As Boolean = (8000000*0);
    }
    Dim CameraPointer(0, 0) As Agt = (0);
    Dim num_fin(0, 0) <6000>  As Integer = (0);
    Dim num_void_fin(0, 0) As Integer = (0);
    Dim num_fill_fin(0, 0) As Integer = (0);
    Dim num_insect(0, 0) As Integer = (0);
    Dim T(0, 0) As Integer = (0);
    Dim alpha(0, 0) As Double = (0.0);
    Dim rubble_rate(0, 0) As Double = (0.0);
    Dim T_ex(0, 0) As Integer = (0);
}


//-------------------------------------------------------
// Agent Variable Initial Data
//-------------------------------------------------------
Initial_Value {
    UNIVERSE.NUM_INSECT = 1(50);
    UNIVERSE.T = 1(100);
    UNIVERSE.ALPHA = 1(0.6);
    UNIVERSE.RUBBLE_RATE = 1(0.6);
}


//-------------------------------------------------------
// Agent Rule
//-------------------------------------------------------
#begin_rule UNIVERSE
Univ_Init{
	CreateAgtMulti(universe.map.insect,universe.num_insect)
	ClearConsoleScreen()
	//make_rubble_mix(0.6)
	read_barrier()
	//make_void()
	println("")
	println("start")
	universe.T = 10 ^ (universe.T_ex)
	println(universe.T)
}

sub read_barrier(){
dim i as Integer
dim j as Integer
dim k as Integer
dim n as Integer
dim s_data as String
dim count as Integer 
dim position(3) as Integer
dim ct_token as Integer
dim hoge as String
dim length as Integer

OpenFile("N_50_ave_small_random_barrier_position_list_T_10_2.csv",100,1)
s_data = ReadFile(100)
Do While (IsEofFile(100) == False)
	ct_token = CountToken(s_data)
	for i = 0 to ct_token - 2
		hoge =  GetToken(s_data,i)
		length = len(hoge) - 2
		position(i) = Cint(Mid(hoge,2,length))
	next i
	universe.map.is_void(position(0),position(1),position(2)) = True
	s_data = ReadFile(100)
Loop
CloseFile(100)
}

sub write_parameter(){
	dim n as Integer

	n = GetCountSimulationNumber()
	OpenFileCSV("w_N_"&universe.num_insect&"_ave_small_random_insect_position_list_T_"&universe.T&"_"&n&".csv",n,3)
	WriteFileCSV(n,"N",False)
	WriteFileCSV(n,universe.num_insect,false)
	WriteFileCSV(n,"T",False)
	WriteFileCSV(n,universe.T,false)
	WriteFileCSV(n,"alpha",False)
	WriteFileCSV(n,universe.alpha,false)
	WriteFileCSV(n,"r",False)
	WriteFileCSV(n,2,True)
	CloseFileCSV(n)
}

sub make_void(){
dim i as Integer
dim j as Integer
dim k as Integer

for k= 0 to 39
for j = 0 to GetHeightSpace(universe.map) -1
for i = 0 to GetWidthSpace(universe.map) -1
	if i == 0 or j == GetHeightSpace(universe.map)-1 or j == 0 or i == GetWidthSpace(universe.map) - 1 or k == 39 then
		universe.map.is_void(i,j,k) = true
	end if
next i
next j
next k
}

Univ_Step_Begin{

}

Univ_Step_End{

	//write_csv()
}

sub write_csv(){
	dim insectlist as AgtSet
	dim one as Agt
	dim count as Integer
	dim n as Integer

	n = GetCountSimulationNumber() mod 10
	count = GetCountStep()
	OpenFileCSV("new_N_"&universe.num_insect&"_ave_small_random_insect_position_list_T_"&universe.T&"_alpha_"&universe.alpha&"_"&n&".csv",n,3)
	MakeAgtSet(insectlist,universe.map.insect)
	for each one in insectlist
		WriteFileCSV(n,count,false)
		WriteFileCSV(n,one.ID,false)
		WriteFileCSV(n,one.X,false)
		WriteFileCSV(n,one.Y,false)
		WriteFileCSV(n,one.Z,false)
		WriteFileCSV(n,one.vector_cul(0),false)
		WriteFileCSV(n,one.vector_cul(1),True)
	next one
	CloseFileCSV(n)
}

Univ_Finish{
}

sub make_rubble_mix(rate as Double){
	dim tmp_rate as Double
	dim tmp_number as Integer
	dim max as Integer
	dim height as Integer
	dim width as Integer
	dim x as integer
	dim y as integer
	dim z as integer
	dim r as Double
	dim pattern as Integer

	tmp_rate = 0
	height = GetHeightSpace(universe.map)
	width = GetWidthSpace(universe.map)
	max = height * width * 40
	tmp_number = 0
	println("tmp_number is"&tmp_number)

	Do While tmp_rate < rate
		x = Int(Rnd() * (width))
		y = Int(Rnd() * (height))
		z = Int(Rnd() * (40))
		pattern = Int(Rnd() * 3)
		r = Rnd() * 100
		if x < 4 and y < 4 and z < 4 then
			
		elseif r < 33 then
			tmp_number = tmp_number + make_rubble_board(pattern,x,y,z)
		elseif r < 66 then
			tmp_number = tmp_number + make_rubble_box(x,y,z)
		else
			tmp_number = tmp_number + make_rubble_Pillar(pattern,x,y,z)
		end if		
		tmp_rate = tmp_number / max
		PrintLn("rate is "&tmp_rate)
	Loop
			println("tmp_number is"&tmp_number)
}

function make_rubble_board(pattern as Integer, x as Integer, y as integer ,z as integer)as Integer{
	dim t as Integer
	dim a as Integer
	dim b as Integer
	dim c as Integer
	dim one as Agt
	dim set as AgtSet
	dim temp as AgtSet
	dim ret as Integer
	dim flag as Boolean
	dim kill as AgtSet
	dim i as integer
	dim j as integer

	flag = false
	ret = 64
	if not universe.map.is_void(x,y,z) then
		if pattern == 0 and x< GetWidthSpace(universe.map) -8 and y < GetHeightSpace(universe.map) - 8 then //水平に置く
			Do While Not flag
				if z == 0 then
					flag = true
					break
				end if
				for j = 0 to 4
					for i = 0 to 4
						if universe.map.is_void(i,j,z-1) then
							flag = true
						end if
					next i
				next j
				z = z -1
			Loop
			for t = 0 to 63
				c = t / 8
				b = t Mod 8
				if not universe.map.is_void(x+b,y+c,z) then
					universe.map.is_void(x+b,y+c,z) = true
				else
					ret = ret - 1
				end if
			next t
		elseif pattern == 1 and y < GetHeightSpace(universe.map) - 8 and z < 40 - 8 then // 縦長に置く
			Do While Not flag
				if z == 0 then
					flag = true
					break
				end if
				for j = 0 to 4
					for i = 0 to 4
						if universe.map.is_void(i,j,z-1) then
							flag = true
						end if
					next i
				next j
				z = z -1
			Loop
			for t = 0 to 63
				a = t / 8
				b = t Mod 8
				if not universe.map.is_void(x,y+b,z+a) then
					universe.map.is_void(x,y+b,z+a) = true
				else
					ret = ret - 1
				end if
			next t
		elseif pattern == 2 and x< GetWidthSpace(universe.map) -8 and z < 40 - 8 then // 横長に置く
			Do While Not flag
				if z == 0 then
					flag = true
					break
				end if
				for j = 0 to 4
					for i = 0 to 4
						if universe.map.is_void(i,j,z-1) then
							flag = true
						end if
					next i
				next j
				z = z -1
			Loop
			for t = 0 to 63
				a = t / 8
				c = t Mod 8
				if not universe.map.is_void(x+c,y,z+a) then
					universe.map.is_void(x+c,y,z+a) = true
				else
					ret = ret - 1
				end if
			next one
		else
			ret = 0
		end if
	else
		ret = 0
	end if
	 
	return ret
}

function make_rubble_box(x as Integer,y as integer, z as integer)as Integer{
	dim t as Integer
	dim a as Integer
	dim b as Integer
	dim c as Integer
	dim one as Agt
	dim set as AgtSet
	dim temp as AgtSet
	dim ret as integer
	dim flag as Boolean
	dim kill as AgtSet
	dim i as integer
	dim j as integer

	ret = 64
	flag = false
	if x <= GetWidthSpace(universe.map) - 4 and y <= GetHeightSpace(universe.map) - 4 and z <= 40 - 4 then
		if not universe.map.is_void(x,y,z) then
			Do While Not flag
				if z == 0 then
					flag = true
					break
				end if
				for j = 0 to 4
					for i = 0 to 4
						if universe.map.is_void(i,j,z-1) then
							flag = true
						end if
					next i
				next j
				z = z -1
			Loop
			for t = 0 to 63
				a = t  / 16 
				b = t Mod (16)
				c = b / 4
				b = b Mod 4
 				if not universe.map.is_void(x+b,y+c,z+a) then
		  		universe.map.is_void(x+b,y+c,z+a) = true
		  	else
					ret = ret - 1		  		
		  	end if		  	
			next t
		else
			ret = 0
		end if
	else
		ret = 0
	end if
		
	 
	return ret
}

function make_rubble_Pillar(pattern as Integer,x as Integer,y as integer ,z as integer)as Integer{
	dim set as AgtSet
	dim a as Integer
	dim b as Integer
	dim one as agt
	dim temp as AgtSet
	dim t as Integer
	dim c as Integer
	dim ret as Integer
	dim flag as Boolean
		dim kill as AgtSet
			dim i as integer
	dim j as integer

	ret = 64
	flag = false
	if not universe.map.is_void(x,y,z) then
		if pattern == 0 and x <= GetWidthSpace(universe.map) - 16 and y <= GetHeightSpace(universe.map) - 2 and z <= 40 -2  then
		//横長の柱を作る
			Do While Not flag
				if z == 0 then
					flag = true
					break
				end if
				for j = 0 to 4
					for i = 0 to 4
						if universe.map.is_void(i,j,z-1) then
							flag = true
						end if
					next i
				next j
				z = z -1
			Loop
			for t = 0 to 63
	  		a = t  / 32 
	  		b = t Mod (32)
	  		c = b / 16
	  		b = b Mod 16
				if not universe.map.is_void(x+b,y+c,z+a) then
		  		universe.map.is_void(x+b,y+c,z+a) = true
		  	else
					ret = ret - 1		  		
		  	end if
	  	next one
		elseif pattern == 1 and x <= GetWidthSpace(universe.map) - 2 and y <= GetHeightSpace(universe.map) - 16 and z <= 40 -2 then
		//縦長の柱を作る
			Do While Not flag
				if z == 0 then
					flag = true
					break
				end if
				for j = 0 to 4
					for i = 0 to 4
						if universe.map.is_void(i,j,z-1) then
							flag = true
						end if
					next i
				next j
				z = z -1
			Loop
	 		for t = 0 to 63
	 			a = t  / 32 
	 			b = t Mod (32)
	 			c = b / 2
	 			b = b Mod 2
				if not universe.map.is_void(x+b,y+c,z+a) then
		 			universe.map.is_void(x+b,y+c,z+a) = true
				else
					ret = ret - 1		  	 		 		
		 		end if
	 		next t
	  elseif pattern == 2 and x <= GetWidthSpace(universe.map) - 2 and y <= GetHeightSpace(universe.map) - 2 and z <= 40 - 16 then //立ってる柱を作る
	  	Do While Not flag
				if z == 0 then
					flag = true
					break
				end if
				for j = 0 to 4
					for i = 0 to 4
						if universe.map.is_void(i,j,z-1) then
							flag = true
						end if
					next i
				next j
				z = z -1
			Loop
	 		for t = 0 to 63
	 			a = t  / 4 
	 			b = t Mod (4)
	 			c = b / 2
	 			b = b Mod 2
				if not universe.map.is_void(x+b,y+c,z+a) then
		 			universe.map.is_void(x+b,y+c,z+a) = true
		 		else
					ret = ret - 1		  	 		 		
		 		end if
	 		next one
	  else
	  	ret = 0
		end if
	else
		ret = 0
	end if
	 
	return ret
}
#end_rule UNIVERSE




//-------------------------------------------------------
// Agent Rule
//-------------------------------------------------------
#begin_rule UNIVERSE.MAP.INSECT
Agt_Init{
my.Direction = rnd() * 90
my.forward_vector(0) = Cos(DegreeToRad(my.Direction))
my.forward_vector(1) = Sin(DegreeToRad(my.Direction))
my.do_type = 1
my.ap_or_dis = 1
my.normal_vector(2) = 1
my.touch(2) = 1
my.dis_surface = -1
my.edge_flag = false
my.X = 1 + rnd() *0.5
my.Y = 1 + rnd() *0.5
my.Z = 0
my.T_al = Int(Rnd()*10)
my.state = 0
}

Agt_Step{
	if my.state == 0 then
		do_stop()
	else
		if in_central() then
			do_central()
		else
			if is_touch_new_surface() then
				move_new_surface()
			else
				do_peripheral()
			end if
		end if
	end if
}

sub move_new_surface(){
//新しい面に移る動き
}

sub do_peripheral(){
//周辺部でどう動くか
}

sub do_stop() {
//停止状態でどう動くか
	if my.stop_time > 0 then
		my.stop_time = my.stop_time - 1
	else
		my.state = 0
	end if
}

sub do_central(){
//中央部でどう動くか
	if is_stop_central() then
		stop_insect()
	else
		if my.state != 2 then
			decide_direction_and_distance()
		end if
		forward_one_step()
	end if
}

sub forward_one_step(){
/*
1step分前進する
もし途中で障害物があればその位置で止まる
*/
}

sub decide_direction_and_distance(){
/*
ランダムウォークで次に進む方向とその距離を決定する
*/
}

function in_central() as Boolean{
	dim ret as Boolean
	/*
	どこかが壁に接していたらtrue,どこも接していなければfalse
	*/
	ret = false
	return ret
}

function is_stop_central() as Boolean{
	dim ret as Boolean
	/*
	中央部において止まるかどうか。止まるならtrue,止まらないならfalseを返す
	*/
	ret = false
	return ret
}

sub stop_insect(){
/*
1.停止時間を設定
2.停止状態になる
*/
}

function is_touch_new_surface()as Boolean{
	dim ret as Boolean
/*
新しい面に触れていたらtrue,振れていなければfalseを返す
*/
	ret = false
	return ret
}

/*
function check_void(x as Double,y as Double,z as Double) as Integer{
	dim ret as Integer
	dim max(3) as Integer

	max(0) = GetWidthSpace(universe.map) - 1
	max(1) = GetHeightSpace(universe.map) - 1
	max(2) = 39

	if x < 0 or y < 0 or z < 0 or max(0) < x or max(1) < y or max(2) < z then
		return -1
	elseif universe.map.is_void(x,y,z) == true then
		return 1
	else
		return 0
	end if
}

sub print_all(){
	DebugStr("ID :"&my.ID)
	DebugStr("X :"&my.X&" Y :"&my.Y& " Z :"&my.Z)
	DebugStr("fX :"&my.forward_vector(0)&" fY :"&my.forward_vector(1)& " fZ :"&my.forward_vector(2))
	DebugStr("nX :"&my.normal_vector(0)&" nY :"&my.normal_vector(1)& " nZ :"&my.normal_vector(2))
	DebugStr("tX :"&my.touch(0)&" tY :"&my.touch(1)& " tZ :"&my.touch(2))
	DebugStr("do_type :"&my.do_type)
	DebugStr("edge_flag :"&my.edge_flag)
}

function is_edge()as Boolean{
	dim position(2) as Double
	dim max(2) as Integer
	dim i as Integer
	dim r as Double
	dim ret as Boolean
	
	r = 2

	position(0) = my.X
	position(1) = my.Y
	max(0) = GetWidthSpace(universe.map)
	max(1) = GetHeightSpace(universe.map)

	ret = false
	for i = 0 to 1
		if position(i) < r then
			my.edge(i) = position(i)
			ret = true
		elseif position(i) > max(i) - 1 - r then
			my.edge(i) = position(i) - max(i)
			ret = true
		end if 
	next i

	return ret
}

sub avoid_edge(){
	cal_edge_vector()
	store_edge_vector()
}

sub cal_edge_vector(){
	dim k(3) as Double
	dim f(3) as Double
	dim r as Integer
	dim i as Integer

	r = 2
	for i = 0 to 2
		if my.edge(i) != 0 then
			k(i) = (r / my.edge(i))^2
		else
			k(i) = 0
		end if
		my.edge_vector(i) = my.edge(i) * k(i)
	next i
}

sub store_edge_vector(){
	dim i as Integer
	dim alpha as Double
	dim f(3) as Double
	dim sum as Double

	alpha = Rnd() * 0.4 + 0.5
	for i = 0 to 2
		if my.normal_vector(i) == 0 then
			f(i) = my.forward_vector(i) + alpha * my.edge_vector(i)
		else
			f(i) = 0
		end if
	next i
	sum = Sqr(f(0)^2 + f(1)^2 + f(2)^2)

	if sum != 0 then
		for i = 0 to 2
			my.forward_vector(i) = f(i) / sum
		next i
	end if

	my.do_type = select_do_type()
}

function is_control() as Boolean{
	dim ret as Boolean

	if (GetCountStep() mod universe.T) == my.T_al then
		ret = true
	else
		ret = false
	end if

	return ret
}

sub calculate_repulsive(){
	repulsive_insect()
	repulsive_barrier()
	sum_repulsive()
}
sub sum_repulsive(){
//repulsiveの合計を出す
	dim i as Integer
	dim alpha as Double

	alpha = universe.alpha

	for i = 0 to 2
		my.repulsive_vector(2,i) = alpha * my.repulsive_vector(0,i) + (1 - alpha) * my.repulsive_vector(1,i)
	next i
}

sub repulsive_insect(){
//サイボーグインセクトからの斥力の和を計算
	dim neighbor as AgtSet
	dim r as Double
	dim diff(3) as Double
	dim d as Double
	dim i as Integer
	dim sum as Double

	r = 50
	MakeOneAgtSetAroundOwn(neighbor,r,universe.map.insect,false)
	if CountAgtSet(neighbor) > 0 then
		for Each one in neighbor 
			diff(0) = my.X - one.X + NormInv(Rnd()*0.8+0.1,0,3)
			diff(1) = my.Y - one.Y+ NormInv(Rnd()*0.8+0.1,0,3)
			diff(2) = my.Z - one.Z+ NormInv(Rnd()*0.8+0.1,0,3)
			d = Sqr(diff(0)^2 + diff(1)^2 + diff(2)^2) / r

			if d != 0 then
				for i = 0 to 2
					my.repulsive_vector(0,i) = my.repulsive_vector(0,i) + diff(i) / d ^ 2
				next i
			end if
		next one

		d = Sqr(my.repulsive_vector(0,0)^2 + my.repulsive_vector(0,1)^2 + my.repulsive_vector(0,2)^2)
		if d != 0 then
			for i = 0 to 2
				my.repulsive_vector(0,i) = my.repulsive_vector(0,i)/d
			next i
		end if
		my.vector_cul(0) = d
	end if
}

sub repulsive_barrier(){
//障害物からの斥力の和を計算
	dim objectset as AgtSet
	dim r as Double
	dim normal as Integer
	dim diff(3) as Double
	dim d as Double
	dim n as Integer
	dim i as Integer
	dim j as Integer
	dim k as Integer
	dim position(3) as Integer

	r = 2
	n = get_surface()

	position(0) = my.X
	position(1) = my.Y
	position(2) = my.Z
	
	if n == 0 then
		for i = 0 to 4
			for j = 0 to 4
				if check_void(position(0),position(1) - 2 + i ,position(2) - 2 + j) then
					diff(0) = 0
					diff(1) = my.Y - position(1) - 2 + i
					diff(2) = my.Z - position(2) - 2 + j

					d = Sqr(diff(0)^2 + diff(1)^2 + diff(2)^2) / r
					if d != 0 then
						for k = 0 to 2
							my.repulsive_vector(1,k) = my.repulsive_vector(1,k) + diff(k) / d ^ 3
						next k
					end if
				end if	
			next j
		next i
	elseif n == 1 then
		for i = 0 to 4
			for j = 0 to 4
				if check_void(position(0) - 2 + i,position(1),position(2) - 2 + j) then
					diff(0) = my.X - position(0) - 2 + i
					diff(1) = 0
					diff(2) = my.Z - position(2) - 2 + j

					d = Sqr(diff(0)^2 + diff(1)^2 + diff(2)^2) / r
					if d != 0 then
						for k = 0 to 2
							my.repulsive_vector(1,k) = my.repulsive_vector(1,k) + diff(k) / d ^ 3
						next k
					end if
				end if	
			next j
		next i
	elseif n == 2 then
		for i = 0 to 4
			for j = 0 to 4
				if check_void(position(0) - 2 + i,position(1) - 2 + j,position(2)) then
					diff(0) = my.X - position(0) - 2 + i
					diff(1) = my.Y - position(1) - 2 + j
					diff(2) = 0

					d = Sqr(diff(0)^2 + diff(1)^2 + diff(2)^2) / r
					if d != 0 then
						for k = 0 to 2
							my.repulsive_vector(1,k) = my.repulsive_vector(1,k) + diff(k) / d ^ 3
						next k
					end if
				end if	
			next j
		next i
	else
		DebugStr("miss in repulsive barrier")
		terminateagt(my)
	end if

	d = Sqr(my.repulsive_vector(1,0)^2 + my.repulsive_vector(1,1)^2 + my.repulsive_vector(1,2)^2)
		if d != 0 then
			for i = 0 to 2
				my.repulsive_vector(1,i) = my.repulsive_vector(1,i)/d
			next i
		end if
		my.vector_cul(1) = d


}

function get_surface()as Integer{
	dim ret as Integer
	dim i as Integer

	ret = 0
	for i = 0 to 2
		if my.normal_vector(i) != 0 then
			ret = i
			break
		end if
	next i

	return ret
}

sub decide_vector(){
//斥力から今の垂直な成分を削除
	dim n as Integer
	dim i as Integer
	dim length as Double

	n = get_surface()
	length = 0
	my.repulsive_vector(2,n) = 0 

	for i = 0 to 2
		length = length + my.repulsive_vector(2,i)^2
	next i 
	length = Sqr(length)
	if length != 0 then
		for i = 0 to 2
			my.forward_vector(i) = my.repulsive_vector(2,i) / length
		next i 
	end if

	my.do_type = select_do_type()
}

sub clear_val(){
//毎ステップ初期化必要な変数を初期化する関数
	dim i as Integer
	dim j as Integer
	
	my.dis_surface = -1
	my.is_back = false
	My.is_hemi = false
	my.a_flag = false
	my.edge_flag = false

	for i = 0 to 1
		for j = 0 to 2
			my.repulsive_vector(i,j) = 0
		next j
	next i
}


sub update_normal_vector(){
//あり得ないnormal_Vectorを消す
//これ必要？ちゃんと更新できるならいらなくない？
	dim type as Integer

	type = my.do_type

	if type == 0 then
		my.normal_vector(0) = 0
	elseif type == 1 then
		my.normal_vector(0) = 0
		my.normal_vector(1) = 0
	elseif type == 2 then
		my.normal_vector(0) = 0
		my.normal_vector(2) = 0
	elseif type == 3 then
		my.normal_vector(1) = 0
	elseif type == 4 then
		my.normal_vector(1) = 0
		my.normal_vector(2) = 0
	else
		my.normal_vector(2) = 0
	end if

}

sub delete_touch_vector(){
//あり得ないtouchを消す
	dim type as Integer

	type = my.do_type
	
	if type == 0 then
		my.touch(0) = 0
	elseif type == 1 then
		my.touch(0) = 0
		my.touch(1) = 0
	elseif type == 2 then
		my.touch(0) = 0
		my.touch(2) = 0
	elseif type == 3 then
		my.touch(1) = 0
	elseif type == 4 then
		my.touch(1) = 0
		my.touch(2) = 0
	else
		my.touch(2) = 0
	end if
}

sub update_normal(){
//normalの正負を合わせるため
	dim i as Integer

	for i = 0 to 2
		if my.normal_vector(i) != 0 then
			my.normal_vector(i) = my.touch(i)
		end if
	next i
}

sub forward_step() {

	if is_differernt() then
		step_surface()
		delete_touch_vector()
		update_normal()
	else
		step_direction()
		delete_touch_vector()
		update_normal()

		if not is_step() then
			back_step()
		end if
	end if

}

function is_differernt()as Boolean{
	dim i as Integer
	dim n as Integer
	dim f as Double
	dim ret as Boolean

	n = my.dis_surface
	if n == -1 then
		ret = false
	else
		f = my.forward_vector(n)//GetHistory(my.forward_vector(n),1)
		
		if f != 0 and my.ap_or_dis == -1 then
			ret = true
		else
			ret = false
		end if
	end if
	
	return ret
}

sub back_surface(n as Integer){
	dim pre as Integer
	dim i as Integer
	dim f(3) as Double
	dim a(3) as Double

	a(0) = close_num(my.X) - my.normal_vector(0)
	a(1) = close_num(my.Y) - my.normal_vector(1)
	a(2) = close_num(my.Z) - my.normal_vector(2)

	for i =0 to 2
		f(i) = GetHistory(my.forward_vector(i),1)
		if f(i) != 0 then
			f(i) = f(i) / Abs(f(i))
		end if
		if a(i) < 0 then
			return
		end if
	next i


	if is_filled() then
		my.is_back = true
		prev_forward()
		my.X = GetHistory(my.X,1)
		my.Y = GetHistory(my.Y,1)
		my.Z = GetHistory(my.Z,1)
	else
		if check_void(a(0),a(1),a(2)) == 0 then
			pre = GetHistory(my.touch(n),1)
			if n == 0 and check_void(a(0)+ pre + f(0),a(1),a(2)) == 1 then
				my.X = my.X + pre + f(0)
				my.Y = my.Y 
				my.Z = my.Z
			elseif n == 1 and check_void(a(0),a(1)+pre+f(1),a(2)) == 1 then
				my.X = my.X 
				my.Y = my.Y + pre + f(1)
				my.Z = my.Z 
			elseif check_void(a(0),a(1),a(2)+ pre + f(2)) == 1 then
				my.X = my.X 
				my.Y = my.Y 
				my.Z = my.Z + pre + f(2)
			else
				//ここに入りたくない
					my.is_back = true
					prev_forward()
					my.X = GetHistory(my.X,1)
					my.Y = GetHistory(my.Y,1)
					my.Z = GetHistory(my.Z,1)
				//応急処置
				/*
				DebugStr("miss in back surface")
				DebugStr("      my.X :"&my.X)
				DebugStr("      my.Y :"&my.Y)
				DebugStr("      my.Z :"&my.Z)
				DebugStr("      n :"&n)
				DebugStr("      pre : "&pre)
				for i = 0 to 2
					DebugStr("      a("&i&") : "&a(i))
				next i
				if n == 0 then
				 DebugStr("     check_void(a(0)+ pre + f(0),a(1),a(2))  :" &check_void(a(0)+ pre + f(0),a(1),a(2)))
				 DebugStr("     f(0) :"&f(0))
				elseif n == 1 then
					DebugStr("     check_void(a(0),a(1)+pre+f(1),a(2))  :" &check_void(a(0),a(1)+pre+f(1),a(2)))
					DebugStr("     f(1) :"&f(1))
				else
					DebugStr("     check_void(a(0),a(1),a(2)+ pre + f(2))  :" &check_void(a(0),a(1),a(2)+ pre + f(2)))
					DebugStr("     f(2) :"&f(2))
				end if
				TerminateAgt(my)
				
			end if
			my.is_back = true
			prev_forward()
		end if
	end if
}

sub prev_forward(){
//面を移る前の状態に戻す
	dim i as Integer 
	
	for i = 0 to 2
		my.forward_vector(i) = GetHistory(my.forward_vector(i),1)
		my.touch(i) = GetHistory(my.touch(i),1)
		my.normal_vector(i) = GetHistory(my.normal_vector(i),1)
	next i
	my.do_type = GetHistory(my.do_type,1)
}

sub step_direction(){

	my.X = my.X + my.forward_vector(0) * 0.6
	my.Y = my.Y + my.forward_vector(1) * 0.6
	my.Z = my.Z + my.forward_vector(2) * 0.6

	if my.X < 0 then
		my.X = 0
	end if
	if my.y < 0 then
		my.y = 0
	end if
	if my.z < 0 then
		my.z = 0
	end if

}

function is_step() as Boolean{
	dim ret as Boolean

	if is_filled() then
		ret = false
	else
		if is_float() then
			ret = false
		else
			if not is_jump() then
				if is_pause() then
					ret = false
				else
					ret = true
				end if
			else
				ret = false
			end if
		end if
	end if

	return ret
}

function is_pause() as Boolean{
//触ってる面が途切れたらtrueを返す
	dim type as Integer
	dim ret as Boolean
	dim nx as Integer
	dim ny as Integer
	dim nz as Integer
	dim p(3) as Integer
	dim f(3) as Double
	dim i as Integer
	dim minus(3) as Integer

	for i = 0 to 2
		if my.forward_vector(i) != 0 then
			f(i) = My.forward_vector(i)
			f(i) = f(i) / Abs(f(i))
		else
			f(i) = 0
		end if
		if f(i) < 0 then
			minus(i) = 1
		else
			minus(i) = 0
		end if
	next i
	
	nx = Int(my.X)// + minus(0)
	ny = Int(my.Y)// + minus(1)
	nz = Int(my.Z)// + minus(2)

	p(0) = Int(GetHistory(my.X,1))
	p(1) = Int(GetHistory(my.Y,1))
	p(2) = Int(GetHistory(my.Z,1))


	if nx != my.X then
		nx = nx + minus(0)
		p(0) = p(0) + minus(0)
	end if
	if ny != my.y then
		ny = ny + minus(1)
		p(1) = p(1) + minus(1)
	end if
	if nz != my.z then
		nz = nz + minus(2)
		p(2) = p(2) + minus(2)
	end if
	
	
	type = my.do_type

	if my.is_back or GetHistory(my.do_type,1) == 1 or GetHistory(my.do_type,1) == 2 or GetHistory(my.do_type,1) == 4 then
		ret = false
		return ret 
	end if

	if type == 0 then
		if my.normal_vector(1) == 0 then
			if my.touch(1) != 0 then
				if ny == 0 and my.touch(1) > 0 then
					ret = false
				else
					if nx == 0 then
						ret = false
					elseif check_void(nx,ny - my.touch(1),nz) == 1 and check_void(nx+f(0),ny - my.touch(1),nz) == 0 then
						if my.X == nx or p(0) == nx then
							ret = false
						else
							ret = true
						end if
					else
						ret = false
					end if
				end if
			else
				ret = false
			end if
		else
			if my.touch(2) != 0 then
				if nz == 0 and my.touch(2) > 0 then
					ret = false
				else
					if nx == 0 then
						ret = false
					elseif check_void(nx,ny,nz - my.touch(2)) == 1 and check_void(nx+f(0),ny,nz - my.touch(2)) == 0 then
						if my.X == nx or p(0) == nx then
							ret = false
						else
							ret = true
						end if
					else
						ret = false
					end if
				end if
			else
				ret = false
			end if
		end if
	elseif type == 1 then
		ret = false
	elseif type == 2 then
		ret = false
	elseif type == 3 then
		if my.normal_vector(0) == 0 then
			if my.touch(0) != 0 then
				if nx == 0 and my.touch(0) > 0 then
					ret = false
				else
					if ny == 0 then
						ret = false
					elseif check_void(nx - my.touch(0),ny,nz) == 1 and check_void(nx - my.touch(0),ny+f(1),nz) == 0 then
						if my.Y == ny or p(1) == ny then
							ret = false
						else
							ret = true
						end if
					else
						ret = false
					end if
				end if
			else
				ret = false
			end if
		else
			if my.touch(2) != 0 then
				if nz == 0 and my.touch(2) > 0 then
					ret = false
				else
					if ny == 0 then
						ret = false
					elseif check_void(nx,ny,nz - my.touch(2)) == 1 and check_void(nx,ny+f(1),nz - my.touch(2)) == 0 then
						if my.Y == ny or p(1) == ny then
							ret = false
						else
							ret = true
						end if
					else
						ret = false
					end if
				end if
			else
				ret = false
			end if
		end if
	elseif type == 4 then
		ret = false
	else
		if my.normal_vector(0) == 0 then
			if my.touch(0) != 0 then
				if nx == 0 and my.touch(0) > 0 then
					ret = false
				else
					if nz == 0 then
						ret = false
					elseif check_void(nx - my.touch(0),ny,nz) == 1 and check_void(nx - my.touch(0),ny,nz+f(2)) == 0 then
						if my.Z == nz or p(2) == nz then
							ret = false
						else
							ret = true
							//DebugStr("5")
						end if
					else
						ret = false
					end if
				end if
			else
				ret = false
			end if
		else
			if my.touch(1) != 0 then
				if ny == 0 and my.touch(1) > 0 then
					ret = false
				else
					if nz == 0 then
						ret = false
					elseif check_void(nx,ny - my.touch(1),nz) == 1 and check_void(nx,ny - my.touch(1),nz+f(2)) == 0 then
						if my.Z == nz or p(2) == nz then
							ret = false
						else
							ret = true
							//DebugStr("6")
						end if
					else
						ret = false
					end if
				end if
			else
				ret = false
			end if
		end if
	end if

	return ret
}

function is_jump() as Boolean{
//さっきまでの面を飛び出したかどうか
	dim type as Integer
	dim ret as Boolean
	dim nx as Integer
	dim ny as Integer
	dim nz as Integer

	nx = Int(my.X)
	ny = Int(my.Y)
	nz = Int(my.Z)
	
	type = my.do_type

	if type == 0 then
		if my.normal_vector(1) == 0 then
			if nz == 0 and my.normal_vector(2) > 0 then
				ret = false
			else
				if check_void(nx,ny,nz - my.normal_vector(2)) == 1 and check_void(nx+1,ny,nz - my.normal_vector(2)) == 1 then
					ret = false
				else
					if my.X == nx then
							ret = false
						else
							ret = true
						end if
				end if
			end if
		else
			if ny == 0 and my.normal_vector(1) > 0 then
				ret = false
			else
				if check_void(nx,ny - my.normal_vector(1),nz) == 1 and check_void(nx+1,ny - my.normal_vector(1),nz) == 1 then
					ret = false
				else
					if my.x == nx then
							ret = false
						else
							ret = true
						end if
				end if
			end if
		end if
	elseif type == 1 then
		if nz == 0 and my.normal_vector(2) > 0 then
			ret = false
		else
			if ny == my.Y then
				if check_void(nx,ny,nz - my.normal_vector(2)) == 1 and check_void(nx+1,ny,nz - my.normal_vector(2)) == 1 then
					ret = false
				else
					if my.x == nx then
							ret = false
						else
							ret = true
						end if
				end if
			elseif nx == my.X then
				if check_void(nx,ny ,nz - my.normal_vector(2)) == 1 and check_void(nx,ny+1,nz - my.normal_vector(2)) == 1 then
					ret = false
				else
					if my.y == ny then
							ret = false
						else
							ret = true
						end if
				end if
			else
				if check_void(nx,ny,nz - my.normal_vector(2)) == 1 and check_void(nx+1,ny,nz - my.normal_vector(2)) == 1 and check_void(nx,ny+1,nz - my.normal_vector(2)) == 1 and check_void(nx+1,ny+1,nz - my.normal_vector(2)) == 1  then
					ret = false
				else
					ret = true
				end if
			end if
		end if
	elseif type == 2 then
		if ny == 0 and my.normal_vector(1) > 0 then
			ret = false
		else
			if nz == my.z then
				if check_void(nx,ny- my.normal_vector(1),nz) == 1 and check_void(nx+1,ny- my.normal_vector(1),nz) == 1 then
					ret = false
				else
					if my.x == nx then
							ret = false
						else
							ret = true
						end if
				end if
			elseif nx == my.X then
				if check_void(nx,ny- my.normal_vector(1) ,nz) == 1 and check_void(nx,ny- my.normal_vector(1),nz+1) == 1 then
					ret = false
				else
					if my.Z == nz then
							ret = false
						else
							ret = true
						end if
				end if
			else
				if check_void(nx,ny- my.normal_vector(1),nz) == 1 and check_void(nx+1,ny- my.normal_vector(1),nz) == 1 and check_void(nx,ny- my.normal_vector(1),nz+1) == 1 and check_void(nx+1,ny- my.normal_vector(1),nz+1) == 1  then
					ret = false
				else
					ret = true
				end if
			end if
		end if
	elseif type == 3 then
		if my.normal_vector(0) == 0 then
			if nz == 0 and my.normal_vector(2) > 0 then
				ret = false
			else
				if check_void(nx,ny,nz - my.normal_vector(2)) == 1 and check_void(nx,ny+1,nz - my.normal_vector(2)) == 1 then
					ret = false
				else
					if my.y == ny then
							ret = false
						else
							ret = true
						end if
				end if
			end if
		else
			if nx == 0 and my.normal_vector(0) > 0 then
				ret = false
			else
				if check_void(nx - my.normal_vector(0),ny,nz) == 1 and check_void(nx - my.normal_vector(0),ny+1,nz) == 1 then
					ret = false
				else
					if my.y == ny then
							ret = false
						else
							ret = true
						end if
				end if
			end if
		end if
	elseif type == 4 then
		if nx == 0 and my.normal_vector(0) > 0 then
			ret = false
		else
			if nz == my.z then
				if check_void(nx- my.normal_vector(0),ny,nz)==1 and check_void(nx- my.normal_vector(0),ny+1,nz) == 1 then
					ret = false
				else
					if my.y == ny then
							ret = false
						else
							ret = true
						end if
				end if
			elseif ny == my.y then
				if check_void(nx- my.normal_vector(0),ny ,nz) == 1 and check_void(nx- my.normal_vector(0),ny,nz+1) == 1 then
					ret = false
				else
					if my.Z == nz then
							ret = false
						else
							ret = true
						end if
				end if
			else
				if check_void(nx- my.normal_vector(0),ny,nz) == 1 and check_void(nx- my.normal_vector(0),ny+1,nz) == 1 and check_void(nx- my.normal_vector(0),ny,nz+1) == 1 and check_void(nx- my.normal_vector(0),ny+1,nz+1) == 1  then
					ret = false
				else
					ret = true
				end if
			end if
		end if
	else
		if my.normal_vector(0) == 0 then
			if ny == 0 and my.normal_vector(1) > 0 then
				ret = false
			else
				if check_void(nx,ny - my.normal_vector(1),nz) == 1 and check_void(nx,ny - my.normal_vector(1),nz+1) == 1 then
					ret = false
				else
					if my.Z == nz then
							ret = false
						else
							ret = true
						end if
				end if
			end if
		else
			if nx == 0 and my.normal_vector(0) > 0 then
				ret = false
			else
				if check_void(nx - my.normal_vector(0),ny,nz) == 1 and check_void(nx - my.normal_vector(0),ny,nz+1) == 1 then
					ret = false
				else
					if my.Z == nz then
							ret = false
						else
							ret = true
						end if
				end if
			end if
		end if
	end if

	return ret
}

function close_num(x as Double) as Integer{
	dim n as Integer
	dim ret as Integer

	n = Int(x)

	if x - n >= 0.5 then
		ret = n + 1
	else
		ret = n
	end if

	return ret
}

function type_gap(x as Double,a as Integer) as Integer{
	dim ret as Integer

	if x - a > 0 then
		ret = 1
	elseif x - a < 0 then
		ret = -1
	else
		ret = 0
	end if

	return ret
}

function is_filled() as Boolean{
	dim i as Integer
	dim j as Integer
	dim k as Integer
	dim a(3) as Integer
	dim x(3) as Double
	dim g(3) as Integer
	dim ret as Boolean

	x(0) = my.X
	x(1) = my.Y
	x(2) = my.Z

		//DebugStr("近いマス")
	for i = 0 to 2
		a(i) = close_num(x(i))
		//DebugStr("a("&i&")"&"is"&a(i))
	next i

	ret = false
	for i = 0 to 2
		if a(i) == 0 then
			g(i) = 0
		else
			g(i) = 1
		end if
	next i
	
	for k = 0 to (1 + g(2))
	 for j = 0 to (1 + g(1))
	 	for i = 0 to (1 + g(0))
			if check_void(a(0)-g(0)+i,a(1)-g(1)+j,a(2)-g(2)+k) == 1 then
	 			if abs(a(0) - g(0) + i  - my.X) < 1 and abs(a(1) - g(1) + j  - my.y) < 1 and abs(a(2) - g(2) + k  - my.z) < 1 then
	 				ret = true
	 				return ret
	 			end if
	 		end if
	 	next i
	 next j
	next k

	return ret
}

function is_float() as Boolean{
	dim i as Integer
	dim j as Integer
	dim k as Integer
	dim a(3) as Integer
	dim x(3) as Double
	dim g(3) as Integer
	dim ret as Boolean

	x(0) = my.X
	x(1) = my.Y
	x(2) = my.Z

	for i = 0 to 2
		a(i) = close_num(x(i))
	next i

	ret = false
	for i = 0 to 2
		if a(i) == 0 then
			g(i) = 0
		else
			g(i) = 1
		end if
	next i

	if x(0) == 0 or x(1) == 0 or x(2) == 0 then
		ret = false
		return ret
	end if
	
	for k = 0 to (1 + g(2))
	 for j = 0 to (1 + g(1))
	 	for i = 0 to (1 + g(0))
	 		if check_void(a(0)-g(0)+i,a(1)-g(1)+j,a(2)-g(2)+k) == 1 then
	 			if abs(a(0) - g(0) + i  - my.X) > 1 and abs(a(1) - g(1) + j  - my.y) > 1 and abs(a(2) - g(2) + k  - my.z) > 1 then
	 				ret = true
	 				return ret
	 			end if
	 		end if
	 	next i
	 next j
	next k

	return ret
}

sub back_step(){
	dim n(3) as Integer
	dim diff_x as Double
	dim diff_y as Double
	dim diff_z as Double
	dim pre(3) as Double
	dim u(3) as Double
	dim k(3) as Double
	dim pre_n(3) as Double
	dim i as Integer
	dim ak(3) as Double 

	pre(0) = GetHistory(my.X,1)
	pre(1) = GetHistory(my.y,1)
	pre(2) = GetHistory(my.z,1)

	k(0) = 0
	k(1) = 0
	k(2) = 0

	u(0) = my.forward_vector(0)//my.X - pre_x
	u(1) = my.forward_vector(1)//my.y - pre_y
	u(2) = my.forward_vector(2)//my.z - pre_z

	n(0) = Int(my.X)
	n(1) = Int(my.Y)
	n(2) = Int(my.Z)

	pre_n(0) = Int(pre(0))
	pre_n(1) = Int(pre(1))
	pre_n(2) = Int(pre(2))

	for i = 0 to 2
		if n(i) == pre_n(i) or u(i) == 0 then
			k(i) = 0
		else
			if n(i) > pre_n(i) then
				k(i) = (n(i) - pre(i)) / u(i)
			else
				k(i) = (pre_n(i) - pre(i)) / u(i)
			end if
		end if
		ak(i) = Abs(k(i))
		if k(i) < 0 then
			k(i) = 0
		end if
	next i

	if ak(0) <= ak(1) and ak(1) <= ak(2) then
		my.X = pre(0) + k(2) * u(0)
		my.y = pre(1) + k(2) * u(1)
		my.z = pre(2) + k(2) * u(2)
		back_0()
		
		if not is_step() then
			my.X = pre(0) + k(1) * u(0)
			my.y = pre(1) + k(1) * u(1)
			my.z = pre(2) + k(1) * u(2)
			back_0()

			if not is_step() then
				my.X = pre(0) + k(0) * u(0)
				my.y = pre(1) + k(0) * u(1)
				my.z = pre(2) + k(0) * u(2)
				back_0()
			end if
		end if
	elseif ak(0) <= ak(2) and ak(2) <= ak(1) then
		my.X = pre(0) + k(1) * u(0)
		my.y = pre(1) + k(1) * u(1)
		my.z = pre(2) + k(1) * u(2)
		back_0()

		if not is_step() then
			my.X = pre(0) + k(2) * u(0)
			my.y = pre(1) + k(2) * u(1)
			my.z = pre(2) + k(2) * u(2)
			back_0()

			if not is_step() then
				my.X = pre(0) + k(0) * u(0)
				my.y = pre(1) + k(0) * u(1)
				my.z = pre(2) + k(0) * u(2)
				back_0()
			end if
		end if
	elseif ak(1) <= ak(0) and k(0) <= ak(2) then
		my.X = pre(0) + k(2) * u(0)
		my.y = pre(1) + k(2) * u(1)
		my.z = pre(2) + k(2) * u(2)
		back_0()

		if not is_step() then
			my.X = pre(0) + k(0) * u(0)
			my.y = pre(1) + k(0) * u(1)
			my.z = pre(2) + k(0) * u(2)
			back_0()

			if not is_step() then
				my.X = pre(0) + k(1) * u(0)
				my.y = pre(1) + k(1) * u(1)
				my.z = pre(2) + k(1) * u(2)
				back_0()
			end if
		end if
	elseif ak(1) <= ak(2) and k(2) <= ak(0) then
		my.X = pre(0) + k(0) * u(0)
		my.y = pre(1) + k(0) * u(1)
		my.z = pre(2) + k(0) * u(2)
		back_0()

		if not is_step() then
			my.X = pre(0) + k(2) * u(0)
			my.y = pre(1) + k(2) * u(1)
			my.z = pre(2) + k(2) * u(2)
			back_0()

			if not is_step() then
				my.X = pre(0) + k(1) * u(0)
				my.y = pre(1) + k(1) * u(1)
				my.z = pre(2) + k(1) * u(2)
				back_0()
			end if
		end if
	elseif ak(2) <= ak(0) and k(0) <= ak(1) then
		my.X = pre(0) + k(1) * u(0)
		my.y = pre(1) + k(1) * u(1)
		my.z = pre(2) + k(1) * u(2)
		back_0()

		if not is_step() then
			my.X = pre(0) + k(0) * u(0)
			my.y = pre(1) + k(0) * u(1)
			my.z = pre(2) + k(0) * u(2)
			back_0()

			if not is_step() then
				my.X = pre(0) + k(2) * u(0)
				my.y = pre(1) + k(2) * u(1)
				my.z = pre(2) + k(2) * u(2)
				back_0()
			end if
		end if
	else			
		my.X = pre(0) + k(0) * u(0)
		my.y = pre(1) + k(0) * u(1)
		my.z = pre(2) + k(0) * u(2)
		back_0()

		if not is_step() then
			my.X = pre(0) + k(1) * u(0)
			my.y = pre(1) + k(1) * u(1)
			my.z = pre(2) + k(1) * u(2)
			back_0()

			if not is_step() then
				my.X = pre(0) + k(2) * u(0)
				my.y = pre(1) + k(2) * u(1)
				my.z = pre(2) + k(2) * u(2)
				back_0()
			end if
		end if
	end if
}

sub back_0(){
	if my.X < 0 then
		my.X = 0
	end if
	if my.Y < 0 then
		my.Y = 0
	end if
	if my.Z < 0 then
		my.Z = 0
	end if
}


sub determining_bend(){
	dim degree as double
	dim sum as Integer
	dim prob(3) as Double
	dim r as Double
	dim rad as Double
	dim i as Integer
	dim x as Double
	dim y as Double
	dim z as Double

	
	degree = NormInv(Rnd(),0,30)
	rad = DegreeToRad(degree)
	x = my.forward_vector(0)
	y = my.forward_vector(1)
	z = my.forward_vector(2)



	sum = Abs(my.touch(0)) + Abs(my.touch(1)) + Abs(my.touch(2))
	r = Rnd()
	for i = 0 to 2	
		prob(i) = Abs(my.touch(i)) / sum
	next i

	if r < prob(0) and my.normal_vector(0) != 0 then
		my.forward_vector(1) = Cos(rad) * y - Sin(rad) * z
		my.forward_vector(2) = Sin(rad) * y + cos(rad) * z 		 
		my.do_type = 4
		my.normal_vector(0) = my.touch(0)
	elseif r < prob(0) + prob(1) and my.normal_vector(1) != 0 then
		my.forward_vector(0) = Cos(rad) * x + Sin(rad) * z 
		my.forward_vector(2) = (-1) * Sin(rad) * x + cos(rad) * z
		my.do_type = 2	
		my.normal_vector(1) = my.touch(1)	 
	elseif my.normal_vector(2) != 0 then
		my.forward_vector(0) = Cos(rad) * x - Sin(rad) * y 
		my.forward_vector(1) = Sin(rad) * x + cos(rad) * y 		 
		my.do_type = 1
		my.normal_vector(2) = my.touch(2)
	else
		/*DebugStr("miss in determing bend")
		for i = 0 to 2	
			DebugStr("     prob("&i&") :"&prob(i))
		next i
		for i = 0 to 2	
			DebugStr("     normal("&i&") :"&my.normal_vector(i))
		next i
		DebugStr("    r :"&r)
		TerminateAgt(my)
	end if

	my.do_type = select_do_type()

}


sub determining_vector(){
	
	calculate_vector()
				DebugStr("   in determing                      matrix(0)"&my.next_vector(2,0))
	      DebugStr("                                             matrrix(1)"&my.next_vector(2,1))
       	DebugStr("                                             matrix(2)"&my.next_vector(2,2))
	select_vector()
}

sub calculate_vector(){
//my.next_vectorに3種類計算する．2種類しかないときは空いてるところに(0,0,0)を入れる
	dim b_type as Integer
	dim angle as Double

	store_vector(my.b_type,my.angle_surface)
	
}

sub store_vector(type as Integer,angle as Double){
//ベクトルをそれぞれ計算して格納する．この時に行けないベクトルも削除する
	dim R(3,3) as Double
	dim x(3) as Double
	dim u(3) as Integer
	dim length as Double
	dim k as Integer
	dim n as Integer
	dim i as Integer
	dim pre_t(3) as Integer

	n = -1
	for i = 0 to 2	
		pre_t(i) = GetHistory(my.touch(i),1)
		if my.normal_vector(i) != 0 then
			n = i
		end if
	next i
	type = my.b_type
	angle = my.angle_surface
	if n == -1 then
		DebugStr("normal miss in store vector1")
		terminateagt(my)
	end if

	my.next_vector(2,0) = 0
	my.next_vector(2,1) = 0
	my.next_vector(2,2) = 0
	if type > 2 then
	//±の障害物見てベクトルの方向を決める
		if type == 3 then
			my.next_vector(0,0) = 0
			if my.ap_or_dis == 1 then
				my.next_vector(0,1) = pre_t(1)
			else
				if my.dis_surface == 1 then
					my.next_vector(0,1) = - my.touch(1)
				else
					my.next_vector(0,1) = my.touch(1)
				end if
			end if
			my.next_vector(0,2) = 0	

			if my.ap_or_dis == 1 then
				my.next_vector(1,0) = pre_t(0)
			else
				if my.dis_surface == 0 then
					my.next_vector(1,0) = - my.touch(0)
				else
					my.next_vector(1,0) =  my.touch(0)
				end if
			end if
			my.next_vector(1,1) = 0
			my.next_vector(1,2) = 0

			if my.ap_or_dis == 1 or n == my.dis_surface then
				if my.normal_vector(0) != 0 then
					my.n_normal(0) = 0
					my.n_normal(1) = 2
				else
					my.n_normal(0) = 2
					my.n_normal(1) = 1
				end if
			else
				if my.normal_vector(0) == 0 then
					my.n_normal(0) = 0
					my.n_normal(1) = 1
				else
					my.n_normal(0) = 0
					my.n_normal(1) = 1
				end if
			end if
		elseif type == 4 then
			my.next_vector(1,0) = 0
			my.next_vector(1,1) = 0
			if my.edge_flag then
				my.next_vector(1,2) = 0
			else
				if my.ap_or_dis == 1 then
					my.next_vector(1,2) = pre_t(2)
				else
					if my.dis_surface == 2 then
						my.next_vector(1,2) = - my.touch(2)
					else
						my.next_vector(1,2) =  my.touch(2)
					end if
				end if
			end if
			

			if my.ap_or_dis == 1 then
				my.next_vector(0,0) = pre_t(0)
			else
				if my.dis_surface == 0 then
					my.next_vector(0,0) = - my.touch(0)
				else
					my.next_vector(0,0) =  my.touch(0)
				end if
			end if
			my.next_vector(0,1) = 0
			my.next_vector(0,2) = 0

			if my.ap_or_dis == 1 or n == my.dis_surface then
				if my.normal_vector(0) == 0 then
					my.n_normal(0) = 2
					my.n_normal(1) = 1
				else
					my.n_normal(0) = 1
					my.n_normal(1) = 0
				end if
			else
				if my.normal_vector(0) == 0 then
					my.n_normal(0) = 2
					my.n_normal(1) = 0
				else
					my.n_normal(0) = 2
					my.n_normal(1) = 0
				end if
			end if
		elseif type == 5 then
			my.next_vector(1,0) = 0
			my.next_vector(1,1) = 0
			if my.edge_flag then
				my.next_vector(1,2) = 0
			else
				if my.ap_or_dis == 1 then
					my.next_vector(1,2) = pre_t(2)
				else
					if my.dis_surface == 2 then
						my.next_vector(1,2) = - my.touch(2)
					else
						my.next_vector(1,2) = my.touch(2)
					end if
				end if
			end if	

			my.next_vector(0,0) = 0
			if my.ap_or_dis == 1 then
				my.next_vector(0,1) = pre_t(1)
			else
				if my.dis_surface == 1 then
					my.next_vector(0,1) = - my.touch(1)
				else
					my.next_vector(0,1) =  my.touch(1)
				end if
			end if
			my.next_vector(0,2) = 0

			if my.ap_or_dis == 1 or n == my.dis_surface then
				if my.normal_vector(1) == 0 then
					my.n_normal(0) = 2
					my.n_normal(1) = 0
				else
					my.n_normal(0) = 0
					my.n_normal(1) = 1
				end if
			else
				if my.normal_vector(1) == 0 then
					my.n_normal(0) = 2
					my.n_normal(1) = 1
				else
					my.n_normal(0) = 2
					my.n_normal(1) = 1
				end if
			end if
		else
			DebugStr("type miss in store vector2")
			TerminateAgt(my)
		end if
	else
		if type == 0 then
			my.next_vector(0,0) = 1
			my.next_vector(0,1) = 0
			my.next_vector(0,2) = 0

			my.next_vector(1,0) = -1
			my.next_vector(1,1) = 0
			my.next_vector(1,2) = 0
			
			u(0) = 1
			u(1) = 0
			u(2) = 0

			if not my.is_hemi and not my.edge_flag then
				matrix()
/*				my.next_vector(2,0) = my.forward_vector(0)
				my.next_vector(2,1) = Abs(my.forward_vector(2)) * pre_t(1) * my.ap_or_dis
				my.next_vector(2,2) = Abs(my.forward_vector(1)) * pre_t(2) * my.ap_or_dis
			end if

			if my.normal_vector(1) == 0 then
				my.n_normal(0) = 2
				my.n_normal(1) = 2
				my.n_normal(2) = 1
			else
				my.n_normal(0) = 1
				my.n_normal(1) = 1
				my.n_normal(2) = 2
			end if
		elseif type == 1 then
			my.next_vector(0,0) = 0
			my.next_vector(0,1) = 1
			my.next_vector(0,2) = 0

			my.next_vector(1,0) = 0
			my.next_vector(1,1) = -1
			my.next_vector(1,2) = 0
			
			u(0) = 0
			u(1) = 1
			u(2) = 0

			if not my.is_hemi and not my.edge_flag then
	/*			my.next_vector(2,0) = Abs(my.forward_vector(2)) * pre_t(0) * my.ap_or_dis
				my.next_vector(2,1) = my.forward_vector(1)
				my.next_vector(2,2) = Abs(my.forward_vector(0)) * pre_t(2) * my.ap_or_dis
				matrix()
			end if

			if my.normal_vector(0) == 0 then
				my.n_normal(0) = 2
				my.n_normal(1) = 2
				my.n_normal(2) = 0
			else
				my.n_normal(0) = 0
				my.n_normal(1) = 0
				my.n_normal(2) = 2
			end if
		elseif type == 2 then
			my.next_vector(0,0) = 0
			my.next_vector(0,1) = 0
			my.next_vector(0,2) = 1

			my.next_vector(1,0) = 0
			my.next_vector(1,1) = 0
			my.next_vector(1,2) = -1
			
			u(0) = 0
			u(1) = 0
			u(2) = 1

			if not my.is_hemi  and not my.edge_flag then
	/*			my.next_vector(2,0) = Abs(my.forward_vector(1)) * pre_t(0) * my.ap_or_dis
				my.next_vector(2,1) = Abs(my.forward_vector(0)) * pre_t(1) * my.ap_or_dis
				my.next_vector(2,2) = my.forward_vector(2)
				matrix()
			end if

			if my.normal_vector(1) == 0 then
				my.n_normal(0) = 0
				my.n_normal(1) = 0
				my.n_normal(2) = 1
			else
				my.n_normal(0) = 1
				my.n_normal(1) = 1
				my.n_normal(2) = 0
			end if
		else
			DebugStr("type miss in store vector3")
			terminateagt(my)
		end if
	end if
}

sub matrix(){
	dim x(3) as Double
	dim y(3) as Double
	dim b(3) as Double
	dim R(3,3) as Double
	dim i as Integer
	dim j as Integer
	dim theta as Double
	dim n as Integer

	n = my.b_type
	x(0) = my.forward_vector(0)
	x(1) = my.forward_vector(1)
	x(2) = my.forward_vector(2)

	theta = calculate_theta()
	if n == 0 then
		b(0) = -1
		b(1) = 0
		b(2) = 0
	elseif n == 1 then
		b(0) = 0
		b(1) = -1
		b(2) = 0
	elseif n == 2 then
		b(0) = 0
		b(1) = 0
		b(2) = -1
	else
		DebugStr("原因ここやんけ")
	end if

	R(0,0) = b(0)^2 * (1 - Cos(theta)) + Cos(theta)
	R(0,1) = b(0) * b(1) * (1 - Cos(theta)) - b(2) * Sin(theta)
	R(0,2) = b(2) * b(0) * (1 - Cos(theta)) + b(1) * Sin(theta)

	R(1,0) = b(0) * b(1) * (1 - Cos(theta)) + b(2) * Sin(theta)
	R(1,1) = b(1)^2 * (1 - Cos(theta)) + Cos(theta)
	R(1,2) = b(1) * b(2) * (1 - Cos(theta)) - b(0) * Sin(theta)

	R(2,0) = b(2) * b(0) * (1 - Cos(theta)) - b(1) * Sin(theta)
	R(2,1) = b(1) * b(2) * (1 - Cos(theta)) + b(0) * Sin(theta)
	R(2,2) = b(2)^2 * (1 - Cos(theta)) + Cos(theta)

	for i = 0 to 2
		my.next_vector(2,i) = x(0) * R(i,0) + x(1) * R(i,1) + x(2) * R(i,2)
		if Abs(my.next_vector(2,i)) < 0.0000001 then
			my.next_vector(2,i) = 0
		end if
	next i

	for i = 0 to 2
		for j = 0 to 2
			print("     R("&i&","&j&") = "&R(i,j))
		next j
		DebugStr("")
	next i
	for i = 0 to 2
		print("n_vector("&i&") : "&x(0) * R(i,0) + x(1) * R(i,1) + x(2) * R(i,2))
	next i
	DebugStr("")
}

sub select_vector(){
//my.next_vectorから1つ確率で選んでmy.forward_vectorに入れる
	dim i as Integer
	dim prob(3) as Double
	dim r as Double
	dim sum_diff as Double
	
	make_base_vector()
	sum_diff = calclator_sum_diff()
	for i = 0 to 2
		prob(i) = calculate_probabilistic(my.next_vector(i,0),my.next_vector(i,1),my.next_vector(i,2),sum_diff)
	next i
	r = Rnd()

				DebugStr("                                             matrix(0)"&my.next_vector(2,0))
	      DebugStr("                                             matrrix(1)"&my.next_vector(2,1))
       	DebugStr("                                             matrix(2)"&my.next_vector(2,2))
	
	if r < prob(0) then
		set_normal_vector(my.n_normal(0))
		my.forward_vector(0) = my.next_vector(0,0)
		my.forward_vector(1) = my.next_vector(0,1)
		my.forward_vector(2) = my.next_vector(0,2)		
	elseif r < prob(0) + prob(1) then
	  set_normal_vector(my.n_normal(1))
		my.forward_vector(0) = my.next_vector(1,0)
		my.forward_vector(1) = my.next_vector(1,1)
		my.forward_vector(2) = my.next_vector(1,2)	
	else
		set_normal_vector(my.n_normal(2))		
		my.forward_vector(0) = my.next_vector(2,0)
		my.forward_vector(1) = my.next_vector(2,1)
		my.forward_vector(2) = my.next_vector(2,2)
	end if

	my.do_type = select_do_type()
}

sub set_normal_vector(n as Integer){
	dim i as Integer
	dim a as Double
	dim f as Double

	f = set_foward(n)
	//DebugStr("forward is"&f)
	for i = 0 to 2
	//方向を鑑みて1or-1をいれる
	//DebugStr("i is"&i)
	//DebugStr("ap_or_dis is"&my.ap_or_dis)
	a = f * my.ap_or_dis * (-1)
	if a != 0 then
		a = a / Abs(a)
	end if//----------------------------------------------------------------------------------------------------------------------多分個々の条件分岐が怪しい
	if i == n then
		if my.normal_vector(i) == 0 then
			my.normal_vector(i) = a
			if a == 0 then
				print("         error as a")
			end if
		end if
		//DebugStr(i&"th next normal vector"&my.normal_vector(i))
	else
		my.normal_vector(i) = 0
	end if
	next i
}

function set_foward (n as Integer)as Double{
//当たった軸とは違うoベクトルでもないforwardvectorを返す
	dim i as Integer
	dim ret as Double
	dim f as Double
	dim type as Integer

	type = my.b_type

	if type == 0 then
		for i = 0 to 1
			if my.forward_vector(i+1) != 0 then
				ret = my.forward_vector(i+1)
			end if
		next i
	elseif type == 1 then
		for i = 0 to 2
			if i!= 1 and my.forward_vector(i) != 0 then
				ret = my.forward_vector(i)
			end if
		next i
	elseif type == 2 then
		for i = 0 to 1
			if my.forward_vector(i) != 0 then
				ret = my.forward_vector(i)
			end if
		next i
	elseif type == 3 then
		ret = my.forward_vector(2)
	elseif type == 4 then
		ret = my.forward_vector(1)
	else
		ret = my.forward_vector(0)
	end if
	
	return ret
}

function select_do_type() as Integer{
	dim ret as Integer

	if my.forward_vector(0) == 0 then
		if my.forward_vector(1) == 0 then
			ret = 5
		else
			if my.forward_vector(2) == 0 then
				ret = 3
			else
				ret = 4
			end if
		end if
	else
		if my.forward_vector(1) == 0 then
			if my.forward_vector(2) == 0 then
				ret = 0
			else
				ret = 2
			end if
		else
			ret = 1
		end if
	end if

	return ret
}

function calclator_sum_diff()as Double{
	dim diff as Double
	dim i as Integer
	dim tmp as Double

	diff = 0
	for i = 0 to 2
		tmp = Sqr( ( my.base_vector(0) - my.next_vector(i,0) )^2 + ( my.base_vector(1) - my.next_vector(i,1) )^2 + ( my.base_vector(2) - my.next_vector(i,2) )^2 )
		if not (my.next_vector(i,0) == 0 and my.next_vector(i,1) == 0 and my.next_vector(i,2) == 0) then
			diff = diff + tmp
		end if
	next i

	return diff
}

sub make_base_vector(){
	dim g(3) as Double
	dim a(3) as Double
	dim length as Double
	dim i as Integer

	g(0) = 0
	g(1) = 0
	g(2) = -1

	for i = 0 to 2
		a(i) = my.forward_vector(i) + g(i) * (49 / 60)
	next i

	length = Sqr( a(0)^2 + a(1) ^2 + a(2) ^ 2 )

	for i = 0 to 2
		my.base_vector(i) = a(i) / length
	next i
	
}

function calculate_probabilistic(x as Double,y as Double,z as Double, sum_diff as Double) as Double{
	dim diff as Double
	dim ret as Double
	dim n as Integer

	if my.next_vector(2,0) == 0 and my.next_vector(2,1) == 0 and my.next_vector(2,2) == 0 then
		if my.next_vector(1,0) == 0 and my.next_vector(1,1) == 0 and my.next_vector(1,2) == 0 then
			n = 1
		else
			n = 2
		end if
	else
		n = 3
	end if

	if sum_diff == 0 then
		sum_diff = 1
	end if

	diff = Sqr( ( my.base_vector(0) - x )^2 + ( my.base_vector(1) - y )^2 + ( my.base_vector(2) - z )^2 )
	if n == 1 then
		ret =1
	else
		ret = ( 1 - diff / sum_diff ) / ( n -1 )
	end if
	
	return ret
}

function is_bend() as Boolean{
	dim ret as Boolean

	if Rnd() < 0.01 then
		ret = true
	else
		ret = false
	end if
	
	return ret
}

function different_surface() as Boolean{
	dim ret  as Boolean
	dim a as Integer
	dim b as Integer

	ret = false
	if is_appear_surface() then
			my.ap_or_dis = 1
			ret = true
	else
		if is_disappear_surface() then
			my.ap_or_dis = -1
			ret = true
		end if
	end if
	
	return ret
}

function is_appear_surface() as Boolean{
	dim ret as Boolean
	dim axis as Integer
	dim pos as Integer
	dim nx as Integer
	dim ny as Integer
	dim nz as Integer
	dim max(2) as Integer
	dim f(3) as Double
	dim i as Integer

	axis = select_do_type()
	ny = Int(my.Y)
	nz = Int(my.Z)
	nx = Int(my.X)
	max(0) = GetWidthSpace(universe.map) - 1 
	max(1) = GetHeightSpace(universe.map) - 1

	for i = 0 to 2
		if my.forward_vector(i) == 0 then
			f(i) = 0 
		else
			f(i) = my.forward_vector(i) / Abs(my.forward_vector(i))
		end if
	next i	

	my.a_flag = false
	if axis == 0 then
		if nx == my.X then
			if my.forward_vector(0) > 0 then
				if check_void(my.X+1,my.Y,my.Z) == 1 then
					ret = true
					my.angle_surface = -1
					my.b_type = 5
					my.touch(0) = -1
					if my.X + 1 == max(0) then
						my.edge_flag = true
					end if
				else
					ret = false
				end if
			else
				if nx == 0 then
					ret = true
					my.angle_surface = -1
					my.b_type = 5
					my.touch(0) = 1
					my.a_flag = true
				else
					if check_void(my.X-1,my.Y,my.Z) == 1 then
						ret = true
						my.angle_surface = -1
						my.b_type = 5
						my.touch(0) = 1
						if my.X - 1 == 0 then
							my.edge_flag = true
						end if
					else
						ret = false
					end if
				end if			
			end if
		else
			ret = false
		end if
	elseif axis == 1 then
		if nx == my.X then
			if ny == my.Y then
				if check_void(nx+f(0),ny,nz) == 1 /*and check_void(nx+f(0),ny+f(1),nz) == 1 then
					ret = true
					my.angle_surface = 90
					my.b_type = 1
					my.touch(0) = -f(0)
					if nx + f(0) == max(0) or nx + f(0) == 0 then
						my.edge_flag = true
					end if
				elseif check_void(nx,ny+f(1),nz) == 1 /*and check_void(nx+f(0),ny+f(1),nz) == 1 then
					ret = true
					my.angle_surface = 270
					my.b_type = 0
					my.touch(1) = -f(1)
					if ny + f(1) == max(1) or ny + f(1) == 0 then
						my.edge_flag = true
					end if
				else
					ret = false
				end if
			else
				if my.forward_vector(0) > 0 then
					if check_void(nx+1,ny,nz) == 1 and check_void(nx+1,ny+1,nz) == 1 then
						ret = true
						my.angle_surface = 90
						my.b_type = 1
						my.touch(0) = -1
						if nx + 1 == max(0) then
							my.edge_flag = true
						end if
					elseif check_void(nx+1,ny,nz) == 1 or check_void(nx+1,ny+1,nz) == 1 then
						ret = true
						my.angle_surface = 90
						my.b_type = 1
						my.touch(0) = -1
						my.is_hemi = true
						if nx + 1 == max(0) then
							my.edge_flag = true
						end if
					else
						ret = false
					end if
				else
					if check_void(nx-1,ny,nz) == 1 and check_void(nx-1,ny+1,nz) == 1 then
						ret = true
						my.angle_surface = 270
						my.b_type = 1
						my.touch(0) = 1
						if nx - 1 == 0 then
							my.edge_flag = true
						end if
					elseif check_void(nx-1,ny,nz) == 1 or check_void(nx-1,ny+1,nz) == 1 then
						ret = true
						my.angle_surface = 270
						my.b_type = 1
						my.touch(0) = 1
						my.is_hemi = true
						if nx - 1 == 0 then
							my.edge_flag = true
						end if
					else
						ret = false
					end if
				end if
			end if
		elseif ny == my.Y then
			if my.forward_vector(1) > 0 then
				if check_void(nx,ny+1,nz) == 1 and check_void(nx+1,ny+1,nz) == 1 then
					ret = true
					my.angle_surface = 270
					my.b_type = 0
					my.touch(1) = -1
					if ny + 1 == max(1) then
						my.edge_flag = true
					end if
				elseif check_void(nx,ny+1,nz) == 1 or check_void(nx+1,ny+1,nz) == 1 then
					ret = true
					my.angle_surface = 270
					my.b_type = 0
					my.touch(1) = -1
					my.is_hemi = true
					if ny + 1 == max(1) then
						my.edge_flag = true
					end if
				else
					ret = false
				end if
			else
				if check_void(nx,ny-1,nz) == 1 and check_void(nx+1,ny-1,nz) == 1 then
					ret = true
					my.angle_surface = 90
					my.b_type = 0
					my.touch(1) = 1
					if ny - 1 == 0 then
						my.edge_flag = true
					end if
				elseif check_void(nx,ny-1,nz) == 1 or check_void(nx+1,ny-1,nz) == 1 then
					ret = true
					my.angle_surface = 90
					my.b_type = 0
					my.touch(1) = 1
					my.is_hemi = true
					if ny - 1 == max(1) then
						my.edge_flag = true
					end if
				else
					ret = false
				end if
			end if
		else
			ret = false
		end if
	elseif axis == 2 then	
		if nx == my.X then
			if nz == my.Z then
				if check_void(nx+f(0),ny,nz) != 0 /*and check_void(nx+f(0),ny,nz+f(2)) != 0then
					ret = true
					my.angle_surface = 90
					my.b_type = 2
					my.touch(0) = -f(0)
					if nx + f(0) == max(0) or nx + f(0) == 0 then
						my.edge_flag = true
					end if
				elseif check_void(nx,ny,nz+f(2)) != 0 /*and check_void(nx+f(0),ny,nz+f(2)) != 0 then
					ret = true
					my.angle_surface = 270
					my.b_type = 0
					my.touch(2) = -f(2)
					if nz + f(2) == max(1) or nz + f(2) == 0 then
						my.edge_flag = true
					end if
				else
					ret = false
				end if
			else
				if my.forward_vector(0) > 0 then
					if check_void(nx+1,ny,nz) == 1 and check_void(nx+1,ny,nz+1) == 1 then
						ret = true
						my.angle_surface = 90
						my.b_type =2
						my.touch(0) = -1
						if nx + 1 == max(0) then
							my.edge_flag = true
						end if
					elseif check_void(nx+1,ny,nz) == 1 or check_void(nx+1,ny,nz+1) == 1 then
						ret = true
						my.angle_surface = 90
						my.b_type =2
						my.touch(0) = -1
						my.is_hemi = true
						if nx + 1 == max(0) then
							my.edge_flag = true
						end if
					else
						ret = false
					end if
				else
					if check_void(nx-1,ny,nz) == 1 and check_void(nx-1,ny,nz+1) == 1 then
						ret = true
						my.angle_surface = 270
						my.b_type = 2
						my.touch(0) = 1
						if nx - 1 == 0 then
							my.edge_flag = true
						end if
					elseif check_void(nx-1,ny,nz) == 1 or check_void(nx-1,ny,nz+1) == 1 then
						ret = true
						my.angle_surface = 270
						my.b_type = 2
						my.touch(0) = 1
						my.is_hemi = true
						if nx - 1 == 0 then
							my.edge_flag = true
						end if
					else
						ret = false
					end if
				end if
			end if
		elseif nz == my.Z then
			if my.forward_vector(2) > 0 then
				if check_void(nx,ny,nz+1) == 1 and check_void(nx+1,ny,nz+1) == 1 then
					ret = true
					my.angle_surface = 270
					my.b_type = 0
					my.touch(2) = -1
				elseif check_void(nx,ny,nz+1) == 1 or check_void(nx+1,ny,nz+1) == 1 then
					ret = true
					my.angle_surface = 270
					my.b_type = 0
					my.touch(2) = -1
					my.is_hemi = true
				else
					ret = false
				end if
			else
				if nz == 0 then
					ret = true
					my.angle_surface = 90
					my.b_type = 0
					my.touch(2) = 1
				elseif check_void(nx,ny,nz-1) != 0 or check_void(nx+1,ny,nz-1) != 0 then
					ret = true
					my.angle_surface = 90
					my.b_type = 0
					my.touch(2) = 1
					my.is_hemi = true
				else
					ret = false
				end if
			end if
		else
			ret = false
		end if	
	elseif axis == 3 then
		if ny == my.Y then
			if my.forward_vector(1) > 0 then
				if check_void(my.X,my.Y+1,my.Z) == 1 then
					ret = true
					my.angle_surface = -1
					my.b_type =4
					my.touch(1) = -1
					if ny + 1 == max(1) then
						my.edge_flag = true
					end if
				else
					ret = false
				end if
			else
				if ny == 0 then
					ret = true
					my.angle_surface = -1
					my.b_type =4
					my.touch(1) = -1
					my.a_flag = true
				else
					if check_void(my.X,my.Y-1,my.Z) then
						ret = true
						my.angle_surface = -1
						my.b_type =4
						my.touch(1) = 1
						if ny - 1 == 0 then
						my.edge_flag = true
					end if
					else
						ret = false
					end if
				end if			
			end if
		else
			ret = false
		end if	
	elseif axis == 4 then
		if ny == my.y then
			if nz == my.Z then
				if check_void(nx,ny+f(1),nz) != 0 /*and check_void(nx,ny+f(1),nz+f(2)) != 0 then
					ret = true
					my.angle_surface = 90
					my.b_type = 2
					my.touch(1) = -f(1)
					if ny + f(1) == max(1) or ny + f(1) == 0 then
						my.edge_flag = true
					end if
				elseif check_void(nx,ny,nz+f(2)) != 0 /*and check_void(nx,ny+f(1),nz+f(2)) != 0 then
					ret = true
					my.angle_surface = 270
					my.b_type = 1
					my.touch(2) = -f(2)
					if nz + f(2) == max(1) or nz + f(2) == 0 then
						my.edge_flag = true
					end if
				else
					ret = false
				end if
			else
				if my.forward_vector(1) > 0 then
					if check_void(nx,ny+1,nz) == 1 and check_void(nx,ny+1,nz+1) == 1 then
						ret = true
						my.angle_surface = 90
						my.b_type =2
						my.touch(1) = -1
						if ny + 1 == max(1) then
							my.edge_flag = true
						end if
					elseif check_void(nx,ny+1,nz) == 1 or check_void(nx,ny+1,nz+1) == 1 then
						ret = true
						my.angle_surface = 90
						my.b_type =2
						my.touch(1) = -1
						my.is_hemi = true
						if ny + 1 == max(1) then
							my.edge_flag = true
						end if
					else
						ret = false
					end if
				else
					if check_void(nx,ny-1,nz) == 1 and check_void(nx,ny-1,nz+1) == 1 then
						ret = true
						my.angle_surface = 270
						my.b_type =2
						my.touch(1) = 1
						if ny - 1 == 0 then
							my.edge_flag = true
						end if
					elseif check_void(nx,ny-1,nz) == 1 or check_void(nx,ny-1,nz+1) == 1 then
						ret = true
						my.angle_surface = 270
						my.b_type =2
						my.touch(1) = 1
						my.is_hemi = true
						if ny - 1 == 0 then
							my.edge_flag = true
						end if
					else
						ret = false
					end if
				end if
			end if
		elseif nz == my.Z then
			if my.forward_vector(2) > 0 then
				if check_void(nx,ny,nz+1) == 1 and check_void(nx,ny+1,nz+1) == 1 then
					ret = true
					my.angle_surface = 270
					my.b_type =1
					my.touch(2) = -1
				elseif check_void(nx,ny,nz+1) == 1 or check_void(nx,ny+1,nz+1) == 1 then
					ret = true
					my.angle_surface = 270
					my.b_type =1
					my.touch(2) = -1
					my.is_hemi = true
				else
					ret = false
				end if
			else
				if nz == 0 then
					ret = true
					my.angle_surface = 90
					my.b_type =1
					my.touch(2) = 1
				else
					if check_void(nx,ny,nz-1) != 0 and check_void(nx,ny+1,nz-1) != 0 then
						ret = true
						my.angle_surface = 90
						my.b_type =1
						my.touch(2) = 1
					elseif check_void(nx,ny,nz-1) != 0 or check_void(nx,ny+1,nz-1) != 0 then
						ret = true
						my.angle_surface = 90
						my.b_type =1
						my.touch(2) = 1
						my.is_hemi = true
					else
						ret = false
					end if
				end if
			end if
		else
			ret = false
		end if		
	else
		if nz == my.Z then
			if my.forward_vector(2) > 0 then
				if check_void(my.X,my.Y,my.Z+1) == 1 then
					ret = true
					my.angle_surface = -1
					my.b_type =3
					my.touch(2) = -1
				else
					ret = false
				end if
			else
				if nz == 0 then
					ret = true
					my.angle_surface = -1
					my.b_type =3
					my.touch(2) = 1
					my.a_flag = true
				else
					if check_void(my.X,my.Y,my.Z-1) != 0 then
						ret = true
						my.angle_surface = -1
						my.b_type =3
						my.touch(2) = 1
					else
						ret = false
					end if
				end if			
			end if
		else
			ret = false
		end if		
	end if	

	return ret
}

function single(num as Double) as Integer{
	if num > 0 then
		return 1
	elseif num < 0 then
		return -1
	else
		return 0
	end if
}

function is_disappear_surface() as Boolean{
	dim ret as Boolean
	dim axis as Integer
	dim nx as Integer
	dim ny as Integer
	dim nz as Integer
	dim f(3) as Double
	dim i as Integer

	axis = select_do_type()
	ny = Int(my.Y)
	nz = Int(my.Z)
	nx = Int(my.X)

	for i = 0 to 2
		if my.forward_vector(i) != 0 then
			f(i) = My.forward_vector(i) / Abs(My.forward_vector(i))
		else
			f(i) = 0
		end if
	next i

	if axis == 0 then
		if nx == my.X then
			if my.normal_vector(1) == 0 then
				if nz == 0 and my.normal_vector(2) > 0 then
					if ny == 0 and my.touch(1) > 0 then
						ret = false
					elseif check_void(nx+f(0),ny - my.touch(1),nz) == 0 and check_void(nx,ny - my.touch(1),nz ) == 1 then
						ret = true
						my.b_type = 5
						my.dis_surface = 1
						my.touch(0) = -f(0)
						//DebugStr("0")
					else
						ret = false
					end if
				else
					if check_void(nx+f(0),ny,nz - my.normal_vector(2)) ==1 then
						if ny == 0 and my.touch(1) > 0 then
							ret = false
						elseif check_void(nx+ f(0) ,ny - my.touch(1),nz) == 0 and check_void(nx,ny - my.touch(1),nz ) == 1 then
							ret = true
							my.b_type = 5
							my.dis_surface = 1
							my.touch(0) = -f(0)
							//DebugStr("1")
						else
							ret = false
						end if
					else
						ret = true
						my.b_type = 5
						my.dis_surface = 2
						my.touch(0) = -f(0)
						//DebugStr("2")
					end if
				end if
			else
				if ny == 0 and my.normal_vector(1) > 0 then
					ret = false
				else
					if check_void(nx+f(0),ny - my.normal_vector(1),nz) == 1 then
						if nz == 0 and my.touch(2) > 0 then
							ret = false
						elseif check_void(nx+f(0),ny,nz- my.touch(2)) == 0 and check_void(nx,ny,nz - my.touch(2) ) == 1 then
							ret = true
							my.b_type = 5
							my.dis_surface = 2
							my.touch(0) = -f(0)
							//DebugStr("3")
						else
							ret = false
						end if
					else
						ret = true
						my.b_type = 5
						my.dis_surface = 1
						my.touch(0) = -f(0)
						//DebugStr("4")
					end if
				end if
			end if
		else
			ret = false
		end if
	elseif axis == 1 then
		if nx == my.X then
			if nz == 0 and my.normal_vector(2) > 0 then
				ret = false
			else
				if ny == my.Y then
					if check_void(nx,ny,nz - my.normal_vector(2)) == 1 and check_void(nx+f(0),ny,nz - my.normal_vector(2)) == 0 then
						ret = true
						my.b_type = 1
						my.dis_surface = 2
						my.touch(0) = -f(0)
						//DebugStr("5")
					elseif check_void(nx,ny,nz - my.normal_vector(2)) == 1 and check_void(nx,ny+f(1),nz - my.normal_vector(2)) == 0 then
						ret = true
						my.b_type = 0
						my.dis_surface = 2
						my.touch(1) = -f(1)
						//DebugStr("6")
					else
						ret = false
					end if
				else
					if check_void(nx,ny,nz - my.normal_vector(2)) == 1 and check_void(nx+f(0),ny,nz - my.normal_vector(2)) == 0 then
						ret = true
						my.b_type = 1
						my.dis_surface = 2
						my.touch(0) = -f(0)
						//DebugStr("7")
					elseif check_void(nx,ny,nz - my.normal_vector(2)) == 1 and check_void(nx+f(0),ny+1,nz - my.normal_vector(2)) == 0 then
						ret = true
						my.b_type = 1
						my.dis_surface = 2
						my.touch(0) = -f(0)
						//DebugStr("7")
					else
						ret = false
					end if
				end if
			end if
		elseif ny == my.Y then
			if nz == 0 and my.normal_vector(2) > 0 then
				ret = false
			else
				if check_void(nx,ny,nz - my.normal_vector(2)) == 1 and check_void(nx,ny+f(1),nz - my.normal_vector(2)) == 0 then
					ret = true
					my.b_type = 0
					my.dis_surface = 2
					my.touch(1) = -f(1)
					//DebugStr("8")
				elseif check_void(nx,ny,nz - my.normal_vector(2)) == 1 and check_void(nx+1,ny+f(1),nz - my.normal_vector(2)) == 0 then
					ret = true
					my.b_type = 0
					my.dis_surface = 2
					my.touch(1) = -f(1)
					//DebugStr("8")
				else
					ret = false
				end if
			end if
		else
			ret = false
		end if
	elseif axis == 2 then
		if nx == my.X then
			if ny == 0 and my.normal_vector(1) > 0 then
				ret = false
			else
				if nz == my.Z then
					if check_void(nx,ny - my.normal_vector(1),nz) == 1 and check_void(nx+f(0),ny - my.normal_vector(1),nz) == 0 then
						ret = true
						my.b_type = 2
						my.dis_surface = 1
						my.touch(0) = -f(0)
						//DebugStr("9")
					elseif check_void(nx,ny - my.normal_vector(1),nz) == 1 and check_void(nx,ny - my.normal_vector(1),nz+f(2)) == 0 then
						ret = true
						my.b_type = 0
						my.dis_surface = 1
						my.touch(2) = -f(2)
						//DebugStr("10")
					else
						ret = false
					end if
				else
					if check_void(nx,ny- my.normal_vector(1),nz) == 1 and check_void(nx+f(0),ny- my.normal_vector(1),nz) == 0 then
						ret = true
						my.b_type = 2
						my.dis_surface = 1
						my.touch(0) = -f(0)
						//DebugStr("11")
					elseif check_void(nx,ny- my.normal_vector(1),nz) == 1 and check_void(nx+f(0),ny- my.normal_vector(1),nz+1) == 0 then
						ret = true
						my.b_type = 2
						my.dis_surface = 1
						my.touch(0) = -f(0)
						//DebugStr("11")
					else
						ret = false
					end if
				end if
			end if
		elseif nz == my.z then
			if ny == 0 and my.normal_vector(1) > 0 then
				ret = false
			else
				if check_void(nx,ny- my.normal_vector(1),nz) == 1 and check_void(nx,ny- my.normal_vector(1),nz+f(2)) == 0 then
					ret = true
					my.b_type = 0
					my.dis_surface = 1
					my.touch(2) = -f(2)
					//DebugStr("12")
				elseif check_void(nx,ny- my.normal_vector(1),nz) == 1 and check_void(nx+1,ny- my.normal_vector(1),nz+f(2)) == 0 then
					ret = true
					my.b_type = 0
					my.dis_surface = 1
					my.touch(2) = -f(2)
					//DebugStr("12")
				else
					ret = false
				end if
			end if
		else
			ret = false
		end if	
	elseif axis == 3 then
		if ny == my.y then
			if my.normal_vector(0) == 0 then
				if nz == 0 and my.normal_vector(2) > 0 then
					if nx == 0 and my.touch(0) > 0 then
						ret = false
					elseif check_void(nx - my.touch(0),ny+f(1),nz) == 0 and check_void(nx - my.touch(0),ny,nz ) == 1 then
						ret = true
						my.b_type = 4
						my.dis_surface = 0
						my.touch(1) = -f(1)
						//DebugStr("13")
					else
						ret = false
					end if
				else
					if check_void(nx,ny+f(1),nz - my.normal_vector(2)) == 1 then
						if nx == 0 and my.touch(0) > 0 then
							ret = false
						elseif check_void(nx - my.touch(0) ,ny+ f(1),nz) == 0 and check_void(nx - my.touch(0),ny,nz ) == 1 then
							ret = true
							my.b_type = 4
							my.dis_surface = 0
							my.touch(1) = -f(1)
							//DebugStr("14")
						else
							ret = false
						end if
					else
						ret = true
						my.b_type = 4
						my.dis_surface = 2
						my.touch(1) = -f(1)
						//DebugStr("15")
					end if
				end if
			else
				if nx == 0 and my.normal_vector(0) > 0 then
					ret = false
				else
					if check_void(nx - my.normal_vector(0),ny+f(1),nz) == 1 then
						if nz == 0 and my.touch(2) > 0 then
							ret = false
						elseif check_void(nx,ny+f(1),nz- my.touch(2)) == 0 and check_void(nx,ny,nz - my.touch(2) ) == 1 then
							ret = true
							my.b_type = 4
							my.dis_surface = 2
							my.touch(1) = -f(1)
							//DebugStr("16")
						else
							ret = false
						end if
					else
						ret = true
						my.b_type = 4
						my.dis_surface = 0
						my.touch(1) = -f(1)
						//DebugStr("17")
					end if
				end if
			end if
		else
			ret = false
		end if
	elseif axis == 4 then
		if ny == my.y then
			if nx == 0 and my.normal_vector(0) > 0 then
				ret = false
			else
				if nz == my.Z then
					if check_void(nx - my.normal_vector(0),ny,nz) == 1 and check_void(nx - my.normal_vector(0),ny +f(1),nz) == 0 then
						ret = true
						my.b_type = 2
						my.dis_surface = 0
						my.touch(1) = -f(1)
						//DebugStr("18")
					elseif check_void(nx - my.normal_vector(0),ny,nz) == 1 and check_void(nx - my.normal_vector(0),ny,nz+f(2)) == 0 then
						ret = true
						my.b_type = 1
						my.dis_surface = 0
						my.touch(2) = -f(2)
						//DebugStr("19")
					else
						ret = false
					end if
				else
					if check_void(nx - my.normal_vector(0),ny,nz) == 1 and check_void(nx - my.normal_vector(0),ny+f(1),nz) == 0 then
						ret = true
						my.b_type = 2
						my.dis_surface = 0
						my.touch(1) = -f(1)
						//DebugStr("20")
					elseif check_void(nx - my.normal_vector(0),ny,nz) == 1 and check_void(nx - my.normal_vector(0),ny+f(1),nz+1) == 0 then
						ret = true
						my.b_type = 2
						my.dis_surface = 0
						my.touch(1) = -f(1)
						//DebugStr("20")
					else
						ret = false
					end if
				end if
			end if
		elseif nz == my.z then
			if nx == 0 and my.normal_vector(0) > 0 then
				ret = false
			else
				if check_void(nx - my.normal_vector(0),ny,nz) == 1 and check_void(nx - my.normal_vector(0),ny,nz+f(2)) == 0 then
					ret = true
					my.b_type = 1
					my.dis_surface = 0
					my.touch(2) = -f(2)
					//DebugStr("21")
				elseif check_void(nx - my.normal_vector(0),ny,nz) == 1 and check_void(nx - my.normal_vector(0),ny+1,nz+f(2)) == 0 then
					ret = true
					my.b_type = 1
					my.dis_surface = 0
					my.touch(2) = -f(2)
					//DebugStr("21")
				else
					ret = false
				end if
			end if
		else
			ret = false
		end if		
	else
		if nz == my.z then
			if my.normal_vector(0) == 0 then
				if ny == 0 and my.normal_vector(1) > 0 then
					if nx == 0 and my.touch(0) > 0 then
						ret = false
					elseif check_void(nx - my.touch(0),ny,nz+f(2)) == 0 and check_void(nx - my.touch(0),ny,nz ) == 1 then
						ret = true
						my.b_type = 3
						my.dis_surface = 0
						my.touch(2) = -f(2)
						//DebugStr("22")
					else
						ret = false
					end if
				else
					if check_void(nx,ny - my.normal_vector(1),nz+f(2)) == 1 then
						if nx == 0 and my.touch(0) > 0 then
							ret = false
						elseif check_void(nx - my.touch(0) ,ny,nz+ f(2)) == 0 and check_void(nx - my.touch(0),ny,nz ) == 1 then
							ret = true
							my.b_type = 3
							my.dis_surface = 0
							my.touch(2) = -f(2)
							//DebugStr("23")
						else
							ret = false
						end if
					else
						ret = true
						my.b_type = 3
						my.dis_surface = 1
						my.touch(2) = -f(2)
						//DebugStr("24")
					end if
				end if
			else
				if nx == 0 and my.normal_vector(0) > 0 then
					ret = false
				else
					if check_void(nx - my.normal_vector(0),ny,nz+f(2)) == 1 then
						if ny == 0 and my.touch(1) > 0 then
							ret = false
						elseif check_void(nx,ny- my.touch(1),nz+f(2)) == 0 and check_void(nx,ny - my.touch(1) ,nz) == 1 then
							ret = true
							my.b_type = 3
							my.dis_surface = 1
							my.touch(2) = -f(2)
							//DebugStr("25")
						else
							ret = false
						end if
					else
						ret = true
						my.b_type = 3
						my.dis_surface = 0
						my.touch(2) = -f(2)
						//DebugStr("26")
					end if
				end if
			end if
		else
			ret = false
		end if
	end if		
	
	return ret
	}

	sub update_touch() {
	dim x(3) as Double
	dim y(3) as Double
	dim n_v(3) as Double
	dim i as Integer
	dim b as Integer

	b = my.b_type
	for i = 0 to 2
		n_v(i) = my.forward_vector(i)
		x(i) = my.touch(i)
	next i

	if b == 0 then
		y(0) = x(0)
		y(1) = -x(1)
		y(2) = -x(2)
	elseif b == 1 then
		y(0) = -x(0)
		y(1) = x(1)
		y(2) = -x(2)
	elseif b == 2 then
		y(0) = -x(0)
		y(1) = -x(1)
		y(2) = x(2)
	elseif b == 3 then
		if n_v(0) == 0 then
			y(0) = x(0)
			y(1) = -x(1)
		else
			y(0) = -x(0)
			y(1) = x(1)
		end if
		y(2) = - x(2)
	elseif b == 4 then
		if n_v(0) == 0 then
			y(0) = x(0)
			y(2) = -x(2)
		else
			y(0) = -x(0)
			y(2) = x(2)
		end if
		y(1) = - x(1)
	elseif b == 5 then
		if n_v(1) == 0 then
			y(1) = x(1)
			y(2) = -x(2)
		else
			y(1) = -x(1)
			y(2) = x(2)
		end if
		y(0) = - x(0)
	else
		DebugStr("b_type miss in update touch")
		TerminateAgt(my)
	end if

	for i = 0 to 2		
		my.touch(i) = y(i)
	next i
} 


sub step_surface(){
	dim pre(3) as	Integer
	dim f(3) as Double
	dim n as Integer
	dim i as Integer
	dim b as Integer

	n = my.dis_surface
	b = my.b_type
	for i =0 to 2
		pre(i) = GetHistory(my.touch(i),1)
		f(i) = GetHistory(my.forward_vector(i),1)
		if f(i) != 0 then
			f(i) = f(i) / Abs(f(i))
		end if
	next i

	if b < 3 then
		if b == 0 then
			f(0) = 0
		elseif b == 1 then
			f(1) = 0
		elseif b == 2 then
			f(2) = 0
		end if
	end if

	if n == 0 then
		my.X = my.X - pre(0)
		my.Y = my.Y + f(1)
		my.Z = my.Z + f(2)
		back_surface(0)
	elseif n == 1 then
		my.X = my.X + f(0)
		my.Y = my.Y - pre(1)
		my.Z = my.Z + f(2)
		back_surface(1)
	else
		my.X = my.X + f(0)
		my.Y = my.Y + f(1)
		my.Z = my.Z - pre(2)
		back_surface(2)
	end if
	if not my.is_back then
		update_touch()
	end if
	
	my.dis_surface = -1	
}

function calculate_theta() as Double{
	dim theta as Double
	dim n as Integer
	dim i as Integer
	dim jud as Double
	dim f as Double

	for i = 0 to 2
		if my.normal_vector(i) != 0 then
			n = my.normal_vector(i)//正からふれてるかどうか
			break
		end if
	next i

	if my.b_type == 0 then
		if i == 1 then
			f = my.forward_vector(2)
		elseif i == 2 then
			f = -my.forward_vector(1)
		else
			DebugStr("miss in theta1")
		end if
	elseif my.b_type == 1 then
		if i == 0 then
			f = -my.forward_vector(2)
		elseif i == 2 then
			f = my.forward_vector(0)
		else
			DebugStr("miss in theta2")
		end if
	elseif my.b_type == 2 then
		if i == 0 then
			f = my.forward_vector(1)
		elseif i == 1 then
			f = -my.forward_vector(0)
		else
			DebugStr("miss in theta3")
		end if
	else
		DebugStr("miss in theta4")
	end if

	jud = f * n * my.ap_or_dis
	if jud > 0 then
		theta = DegreeToRad(90)
	elseif jud < 0 then
		theta = DegreeToRad(270)
	else
		DebugStr("miss in theta5")
		DebugStr("jud :"&jud)
		theta = DegreeToRad(90)
	end if

	return theta
	}*/
#end_rule UNIVERSE.MAP.INSECT




//-------------------------------------------------------
// Agent Rule
//-------------------------------------------------------
#begin_rule UNIVERSE.MAP.BARRIER
Agt_Init{

}

Agt_Step{

}
#end_rule UNIVERSE.MAP.BARRIER




//-------------------------------------------------------
// Simulation Definition Division
//-------------------------------------------------------
Single_Simulation {
    Step_Max = 100000;
    Time_Max = 0;
    End_Condition = "";
    Exec_Wait = 0;
    Exec_Wait_Max = 1000;
    Random_Generator = Java_Standard;
    Exec_Order = Random;
    Exec_Order_Random_First_Step_Only = No;
    Random_Seed = 0;
    Redraw_Timing = Step;
    Redraw_Interval = 1;
    Garbage_Interval = 0;
}


//-------------------------------------------------------
// Simulation Loop Definition Division
//-------------------------------------------------------
Repeat_Simulation {
    Value_Change = Linear;
    Initial_Value_Change_None {
        Repeat_Max = 7;
    }
    Initial_Value_Change_Linear {
        Variable_Name = "universe.T_ex";
        Exec_Times_Same_Value = 1;
        Start_Value = 1.0;
        Step_Value = 1.0;
        End_Value = 1.0;
    }
}


//-------------------------------------------------------
// Time Graph Output Definition Division
//-------------------------------------------------------
Time_Graph {
    Font_Name = "Dialog";
    Font_Char_Set = 81;
    Font_Size = 12.0;
    Font_Style = 0;
    Font_Color = 0, 0, 0;
    Font_Background_Color = 255, 255, 255;
    Draw_Timing = Simulation_Step;
    Draw_Interval = 1;
    Graph_Name = "test";
    Title = "test";
    Disable = No;
    Background_Color = 255, 255, 255;
    Remarks = Yes;
    Legend_Pos = Top;
    FastDraw = Yes;
    Position_x = 1;
    Position_y = -12;
    Size_x = 1037;
    Size_y = 761;
    Map_Cell_Size = -1;
    Axis_Label = "step", "voxel";
    Draw_By_JFree_Chart = Yes;
    Scale = 0, 0.0, 1000, 100.0, 100, 10.0;
    ScaleAuto = Yes, Yes;
    Output_Group_Name = "";
    Output {
        Graph_Element_Name = "fin";
        Line_Color = 255, 0, 0;
        Line_Width = 2;
        Marker_Id = 0;
        Output_Expression = "universe.num_fin";
        Expression_Value_Display = No;
        Effective_Fraction_Figures = 0;
        Graph_Element_Color = (204, 0, 0);
    }
}


//-------------------------------------------------------
// Control Panel Definition Division
//-------------------------------------------------------
Control_Panel {
    Display_Area = 0, 0, 420, 116;
    Display_Type = 1;
    Panel_Item {
        Item_Type = Edit_Box;
        Item_Name = "rubble_rate";
        Display_Area = 0, 0, 0, 0;
        Font_Name = "";
        Font_Char_Set = 0;
        Font_Size = 0.0;
        Font_Style = 0;
        Font_Color = 0, 0, 0;
        Font_Background_Color = 0, 0, 0;
        Var_Name = "Universe.rubble_rate";
        Text_Data = "0.6";
    }
    Panel_Item {
        Item_Type = Edit_Box;
        Item_Name = "num_insect";
        Display_Area = 0, 0, 0, 0;
        Font_Name = "";
        Font_Char_Set = 0;
        Font_Size = 0.0;
        Font_Style = 0;
        Font_Color = 0, 0, 0;
        Font_Background_Color = 0, 0, 0;
        Var_Name = "Universe.num_insect";
        Text_Data = "50";
    }
    Panel_Item {
        Item_Type = Edit_Box;
        Item_Name = "alpha";
        Display_Area = 0, 0, 0, 0;
        Font_Name = "";
        Font_Char_Set = 0;
        Font_Size = 0.0;
        Font_Style = 0;
        Font_Color = 0, 0, 0;
        Font_Background_Color = 0, 0, 0;
        Var_Name = "Universe.alpha";
        Text_Data = "0.6";
    }
}


//-------------------------------------------------------
// Space Initial Value Definition Divsion
//-------------------------------------------------------
Space_Initial {
}


//-------------------------------------------------------
// Other Miscellaneous Data Definition Division
//-------------------------------------------------------
Others_Data {
    Indent = 4;
    Rule_Colored = Yes;
    Rule_LineNo = Yes;
    Window_Hide_Run = 1;
    Debug_Position_x = 7;
    Debug_Position_y = 8;
    Debug_Size_x = 400;
    Debug_Size_y = 200;
    Console_Position_x = 121;
    Console_Position_y = -23;
    Console_Size_x = 716;
    Console_Size_y = 1072;
    Componen_Tree_Position_x = -24;
    Componen_Tree_Position_y = -3;
    Componen_Tree_Size_x = 250;
    Componen_Tree_Size_y = 400;
    Console_Background_Color = 16777215;
    Console_Foreground_Color = 255;
    Console_DisplayLines_Max = 500;
    plug_in_module_name = "";
    Font_Name = "Dialog";
    Font_Char_Set = 0;
    Font_Size = 14.0;
    Font_Style = 0;
    Font_Color = 0, 0, 0;
    Font_Background_Color = 0, 0, 0;
}


//-------------------------------------------------------
// Network Information Definition Division
//-------------------------------------------------------
Network_Info {
    Global_Space_Area = 0, 0, 100, 100;
    Local_Space_Info {
    }
}


//-------------------------------------------------------
// Space Map Initial Value Definition Division
//-------------------------------------------------------
Space_Map_Initial_Value {
    Space_Path_Name = Universe.map;
    Background_Image_File_Path_Name = "";
    Origin_Position = Left_Bottom;
    Space_Variable {
        Variable = Universe.map.fin,(8000000*0);
        Marker_Id = 1;
        Min_Value = "";
        Max_Value = "";
        Min_Value_Color = 255, 0, 0;
        Max_Value_Color = 0, 255, 255;
    }
    Space_Variable {
        Variable = Universe.map.is_void,(8000000*0);
        Marker_Id = 1;
        Min_Value = "";
        Max_Value = "";
        Min_Value_Color = 255, 0, 0;
        Max_Value_Color = 0, 255, 255;
    }
}


//-------------------------------------------------------
// Window Location Definition Division
//-------------------------------------------------------
Window_Rectangle {
    Window_Name = Main_Window, -10, 0, 980, 1030;
    Window_Name = Output_Setting_Window, 743, 353, 480, 350;
    Window_Name = Artisoc_Help_Window, 10, 10, 400, 300;
    Window_Name = Map_3D_Setting_Window, 631, 271, 680, 500;
    Window_Name = Space_3D_Setting_Window, 746, 251, 450, 540;
}


//-------------------------------------------------------
// Help Favorite Division
//-------------------------------------------------------
Help_Favorite {
}
